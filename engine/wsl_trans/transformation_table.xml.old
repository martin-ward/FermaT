<TransformationTable>
  <Transformation id="//T/R_/Abort_/Processing" name="Abort_Processing" description="Simplify statement sequences containing an ABORT." keywords="Simplify" nodes="T_Abort"/>
  <Transformation id="//T/R_/Absorb_/Left" name="Absorb Left" description="This transformation will absorb into the selected statement the one that precedes it." keywords="Join" nodes="T_Assign#T_Assignment#T_Cond#T_D_If#T_Floop#T_For#T_Statement#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Absorb_/Right" name="Absorb Right" description="This transformation will absorb into the selected statement the one that follows it." keywords="Join" nodes="T_Assert#T_Assign#T_Assignment#T_Exit#T_For#T_Statement#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Actions_/To_/Procs" name="Actions to Procs" description="Search for actions which call one other action and make them into procs." keywords="Rewrite Simplify" nodes="T_A_S"/>
  <Transformation id="//T/R_/Actions_/To_/Where" name="Actions to Where" description="Convert an Action System to a Where clause" keywords="Rewrite Simplify" nodes="T_A_S"/>
  <Transformation id="//T/R_/Add_/Assertion" name="Add Assertion" description="This transformation will add an assertion after the current item, if some suitable information can be ascertained." keywords="Insert" nodes="T_Abort#T_Assert#T_Assign#T_Assignment#T_Cond#T_Condition#T_False#T_Guarded#T_Statement#T_True#T_While"/>
  <Transformation id="//T/R_/Add_/Left" name="Add Left" description="This transformation will add the selected statement (or sequence of statements) into the statement that precedes it without doing further simplification." keywords="Join" nodes="T_Assign#T_Statement"/>
  <Transformation id="//T/R_/Add_/Loop_/To_/Action" name="Add_Loop_To_Action" description="If an action is only called by one other action, in a regular system we can merge the calls to the first action by introducing a Floop, replacing the calls by EXITs and adding a single call after the loop. " keywords="Simplify" nodes="T_A_S"/>
  <Transformation id="//T/R_/Align_/Nested_/Statements" name="Align Nested Statements" description="This transformation takes a guarded clause whose first statement is a If and integrates it with the outer condition by absorbing the other guarded statements into the inner If, and then modifying its conditions appropriately.  This is the converse of Partially Join Cases." keywords="Rewrite " nodes="T_Comment#T_Cond#T_Guarded"/>
  <Transformation id="//T/R_/Apply_/To_/Right" name="Apply To Right" description="This transformation will apply the current program item to the one to its immediate right.  For example, if the current item is an assertion and the next item is an IF statement, then the transformation will attempt to simplify the conditions using the assertions." keywords="Use/Apply" nodes="T_Assert#T_Assign#T_Cond#T_D_Do#T_D_If#T_Statement#T_While"/>
  <Transformation id="//T/R_/Collapse_/Action_/System" name="Collapse Action System" description="Collapse action system will use simplifications and substitution to transform an action system into a sequence of statements, possibly inside a DO loop." keywords="Rewrite" nodes="T_A_S"/>
  <Transformation id="//T/R_/Collapse_/All_/Systems" name="Collapse All Action Systems" description="Collapse All Action Systems will attempt to collapse the action systems within a program  which is a WHERE structure." keywords="Rewrite" nodes="T_Where"/>
  <Transformation id="//T/R_/Combine_/Wheres" name="Combine Where Structures" description="Combine Where Structures will combine two nested WHERE structures into one structure which will contain the definitions from each of the original WHERE structures.   The selected WHERE structure will be merged into an enclosing one if there is one or, failing that, into an enclosed WHERE structure." keywords="Rewrite" nodes="T_Where"/>
  <Transformation id="//T/R_/Constant_/Propagation" name="Constant Propagation" description="Constant Propagation finds assignments of constants to variables in the selected item and propagates the values through the selected item (replacing variables in expressions by the appropriate values)" keywords="Simplify" nodes="T_Condition#T_Expression"/>
  <Transformation id="//T/R_/D_/Do_/To_/Floop" name="D Do To Floop" description="Convert any D_Do loop to a DO...OD loop " keywords="Rewrite" nodes="T_D_Do"/>
  <Transformation id="//T/R_/Decrement_/Statement" name="Decrement_Statement" description="Decrement a statement, provided it is enclosed in a suitable double Floop." keywords="Rewrite" nodes="T_Statement"/>
  <Transformation id="//T/R_/Delete_/All_/Assertions" name="Delete All Assertions" description="This transformation will delete all the ASSERT statements within the selected code.  If the resulting code is not syntactically correct, the program will be tidied up which may well result in the re-instatement of ASSERT or SKIP statements." keywords="Simplify " nodes="T_Assert"/>
  <Transformation id="//T/R_/Delete_/All_/Comments" name="Delete All Comments" description="This transformation will delete all the COMMENT statements within the selected code.  If the resulting code is not syntactically correct, the program will be tidied up which may well result in the insertion of SKIP statements." keywords="Delete " nodes="T_Comment"/>
  <Transformation id="//T/R_/Delete_/All_/Redundant" name="Delete All Redundant" description="Delete All Redundant searches for redundant statements and deletes all the ones it finds. A statement is Redundant if it calls nothing external and the variables it modifies will all be assigned again before their values are accessed. " keywords="Delete" nodes="T_Assign"/>
  <Transformation id="//T/R_/Delete_/All_/Skips" name="Delete All Skips" description="This transformation will delete all the SKIP statements within the selected code.  If the resulting code is not syntactically correct, the program will be tidied up which may well result in the re-instatement of SKIP statements." keywords="Delete Simplify " nodes="T_Skip"/>
  <Transformation id="//T/R_/Delete_/Item" name="Delete Item" description="This transformation will delete a program item that is redundant or unreachable" keywords="Delete" nodes="T_Action#T_And#T_Assert#T_Assign#T_Assignment#T_BFunct#T_Comment#T_Cond#T_Condition#T_Divide#T_Expression#T_False#T_For#T_Funct#T_Guarded#T_Minus#T_Or#T_Plus#T_Proc#T_Skip#T_Statement#T_Statements#T_Times#T_True#T_While"/>
  <Transformation id="//T/R_/Delete_/Redundant_/Statement" name="Delete Redundant Statement" description="Delete Redundant Statement checks whether the current statement is Redundant (because it calls nothing external and the variables it modifies will all be assigned again before their values are accessed). If so, it deletes the Statement. " keywords="Delete" nodes="T_Abort#T_Assert#T_Assign#T_Assignment#T_Comment#T_Error#T_Prinflush#T_Print#T_Rel_Seg_Lvalue#T_Statement#T_Sub_Seg_Lvalue"/>
  <Transformation id="//T/R_/Delete_/Unreachable_/Code" name="Delete Unreachable Code" description="Delete Unreachable Code will remove unreachable statements in the selected object. It will also remove unreachable cases in an IF statement, e.g those which follow a TRUE guard" keywords="Simplify" nodes="T_A_S#T_Cond#T_D_Do#T_D_If#T_False"/>
  <Transformation id="//T/R_/Delete_/What_/Follows" name="Delete What Follows" description="Delete What Follows will delete the code which follows the selected item if it can never be executed" keywords="Use/Apply" nodes="T_Cond#T_Guarded#T_Statement#T_True"/>
  <Transformation id="//T/R_/Double_/To_/Single_/Loop" name="Double to Single Loop" description="Double to Single Loop will convert a double nested loop to a single loop, if this can be done without significantly increasing the size of the program." keywords="Rewrite" nodes="T_Cond#T_Exit#T_Floop"/>
  <Transformation id="//T/R_/Else_/If_/To_/Elsif" name="Else If To Elsif" description="This transformation will replace an Else clause which contains an If statement with an Elsif clause.  The transformation can be selected with either the outer If statement, or the Else clause selected." keywords="Rewrite" nodes="T_Comment#T_Cond#T_Guarded"/>
  <Transformation id="//T/R_/Elsif_/To_/Else_/If" name="Elsif To Else If" description="This transformation will replace an Elsif clause in an If statement with an Else clause which itself contains an If statement.    The transformation can be selected with either the If statement, or the Elsif clause selected." keywords="Rewrite" nodes="T_Cond#T_Guarded"/>
  <Transformation id="//T/R_/Expand_/And_/Separate_/All" name="Expand And Separate All" description="Expand And Separate All will attempt to apply the transformation Expand and Separate to the first statement in each action in an action system. This will be useful for dealing with the skip_flag in WSL derived from Herma" keywords="Simplify" nodes="T_A_S"/>
  <Transformation id="//T/R_/Expand_/And_/Separate" name="Expand And Separate" description="Expand And Separate will expand the selected IF statement to include all the following statements, then separate all possible statements from the resulting IF. This is probably only useful if the IF includes a CALL, EXIT etc. which is duplicated in the following statements, otherwise it will probably achieve nothing." keywords="Reorder" nodes=""/>
  <Transformation id="//T/R_/Expand_/Call" name="Expand Call" description="Expand_Call will replace a call to an action, procedure or function with the corresponding definition." keywords="Rewrite" nodes="T_Actions#T_Call#T_Funct#T_Funct_Call#T_Proc#T_Proc_Call"/>
  <Transformation id="//T/R_/Expand_/Forward" name="Expand Forward" description="Expand_Forward will copy the following statement into the end of each branch of the selected IF or D_IF statement. It differs from Absorb Right in that the statement is only absorbed into the top level of the selected IF" keywords="Join" nodes="T_Cond#T_D_If"/>
  <Transformation id="//T/R_/Find_/Terminals" name="Find_Terminals" description="Find and mark the terminal statements in the selected statement. If a terminal statement is a local proc call, apply recursively to the proc body." keywords="Rewrite" nodes=""/>
  <Transformation id="//T/R_/Flag_/Removal" name="Flag_Removal" description="Attempt to remove references to flag variables " keywords="Simplify" nodes="T_Var"/>
  <Transformation id="//T/R_/Floop_/To_/While" name="Floop To While" description="Convert a suitable DO...OD loop to a While loop " keywords="Rewrite" nodes="T_Call#T_Floop"/>
  <Transformation id="//T/R_/For_/In_/To_/Reduce" name="For_In_To_Reduce" description="Replace a FOR x IN y loop with an equivalent REDUCE" keywords="Simplify " nodes="T_Assert#T_For_In"/>
  <Transformation id="//T/R_/For_/To_/While" name="For_To_While" description="Convert any FOR loop to a VAR plus WHILE loop " keywords="Rewrite" nodes="T_For"/>
  <Transformation id="//T/R_/Force_/Double_/To_/Single_/Loop" name="Force Double - Single Loop" description="Force Double - Single Loop will convert a double nested loop to a single loop, regardless of any increase in program size which this causes" keywords="Rewrite" nodes="T_Floop"/>
  <Transformation id="//T/R_/Fully_/Absorb_/Right" name="Fully Absorb Right" description="This transformation will absorb into the selected statement all the statements that follow it." keywords="Join" nodes="T_Assert#T_Assign#T_Assignment#T_Exit#T_For#T_Statement#T_Statements#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Fully_/Expand_/Forward" name="Fully Expand Forward" description="Apply Expand Forward as often as possible" keywords="Join" nodes=""/>
  <Transformation id="//T/R_/Globalise_/Procs" name="Globalise_Procs" description="Move procs to an enclosing WHERE (opposite of Globalise_Procs)." keywords="Rewrite" nodes="T_Statement#T_Where"/>
  <Transformation id="//T/R_/Globals_/To_/Pars" name="Globals_To_Pars" description="Convert global variables in procs to extra VAR parameters." keywords="Rewrite" nodes="T_Where"/>
  <Transformation id="//T/R_/Ifmatch_/Processing" name="Ifmatch_Processing" description="Convert an IFMATCH statement to a @New_Match call." keywords="Simplify" nodes=""/>
  <Transformation id="//T/R_/Increment_/Statement" name="Increment_Statement" description="Increment a statement, provided it is enclosed in a suitable double Floop." keywords="Rewrite" nodes="T_Assign#T_Floop#T_Statement#T_Statements"/>
  <Transformation id="//T/R_/Insert_/Assertion" name="Insert Assertion(s)" description="This transformation will add an assertion inside the current item, if some suitable information can be ascertained." keywords="Insert" nodes="T_Cond#T_D_Do#T_D_If#T_Guarded#T_While"/>
  <Transformation id="//T/R_/Join_/All_/Cases" name="Join All Cases" description="This transformation will join any guards in an If statement which contain the same sequence of statements (thus reducing their number) by changing the conditions of all the guards as appropriate." keywords="Rewrite Join" nodes="T_Comment#T_Cond"/>
  <Transformation id="//T/R_/Join_/Cases_/Left" name="Join_Cases Left" description="This transformation will merge the selected Guarded clause with the one before it." keywords="Join" nodes="T_Guarded"/>
  <Transformation id="//T/R_/Join_/Cases_/Right" name="Join_Cases Right" description="This transformation will merge the selected Guarded clause with the one after it." keywords="Join" nodes="T_Funct_Call#T_Guarded#T_MW_Funct_Call#T_MW_Proc_Call#T_Proc_Call#T_Skip#T_X_Funct_Call#T_X_Proc_Call"/>
  <Transformation id="//T/R_/Localise_/Procs" name="Localise_Procs" description="Create a local WHERE for procs which are only called in the selected item" keywords="Rewrite" nodes="T_Statement#T_Statements"/>
  <Transformation id="//T/R_/Loop_/Doubling" name="Loop_Doubling" description="Loop doubling will duplicate the body of an Floop." keywords="Insert" nodes="T_Floop"/>
  <Transformation id="//T/R_/Loop_/To_/Move" name="Loop_To_Move" description="Convert a suitable DO...OD or WHILE loop to assignments. " keywords="Rewrite" nodes="T_Floop#T_Greater_Eq#T_Number#T_While"/>
  <Transformation id="//T/R_/Make_/Loop" name="Make_Loop" description="Make loop will increment a statement or statement sequence and put it in a (false) loop." keywords="Insert" nodes="T_Call#T_Statement#T_Statements"/>
  <Transformation id="//T/R_/Make_/Proc" name="Make Procedure" description="Make Procedure will make a procedure from the body of an action or from a list of statements." keywords="Rewrite" nodes="T_Action#T_Call#T_Statement#T_Statements"/>
  <Transformation id="//T/R_/Make_/Reducible" name="Make_Reducible" description="Use absorption if necessary to make the selected item reducible (ie all terminal statements with terminal value 1 are in terminal positions in the given item). " keywords="Rewrite" nodes="T_Statement#T_Statements"/>
  <Transformation id="//T/R_/Merge_/Calls_/In_/Action" name="Merge Calls in Action" description="Merge Calls in Action will attempt to merge calls which call the same action, in the selected action" keywords="Simplify" nodes="T_Action#T_Call#T_Cond"/>
  <Transformation id="//T/R_/Merge_/Calls_/In_/System" name="Merge Calls" description="Use absorption to reduce the number of calls in an action system. " keywords="Simplify" nodes="T_A_S"/>
  <Transformation id="//T/R_/Merge_/Cond_/Right" name="Merge_Cond_Right" description="Merge a binary Cond with a subsequent Cond which uses the same (or the opposite) test" keywords="Simplify" nodes="T_Comment#T_Cond#T_Skip"/>
  <Transformation id="//T/R_/Merge_/Left" name="Merge Left" description="This transformation will merge the selected statement (or sequence of statements) into the statement that precedes it." keywords="Join" nodes="T_Assign#T_Assignment#T_Statement"/>
  <Transformation id="//T/R_/Merge_/Right" name="Merge Right" description="This transformation will merge the selected statement into the statement that precedes it." keywords="Join" nodes="T_Assign#T_Assignment#T_Statement"/>
  <Transformation id="//T/R_/Meta_/Trans" name="Meta Trans" description="Convert a FOREACH with a long sequence of IFMATCH commands to a more efficient form" keywords="Simplify" nodes="T_Foreach_Cond#T_Foreach_Expn#T_Ifmatch_Cond#T_Ifmatch_Expn"/>
  <Transformation id="//T/R_/Move_/Comment_/Left" name="Move Comment Left" description="Moves the selected Comment Left. " keywords="Move" nodes="T_Comment#T_Statement"/>
  <Transformation id="//T/R_/Move_/Comment_/Right" name="Move Comment Right" description="Moves the selected Comment Right. " keywords="Move" nodes="T_Comment#T_Statement"/>
  <Transformation id="//T/R_/Move_/Comments" name="Move Comments" description="Move Comments will move any comments which appear at the end of actions within an action system and which follow a call. The comments will  be moved in front of the call. This will help tidy up the output of the Herma translator." keywords="Rewrite" nodes="T_A_S"/>
  <Transformation id="//T/R_/Move_/To_/Left" name="Move To Left" description="This transformation will move the selected item to the left so that it is exchanged with the item that precedes it." keywords="Move" nodes="T_Assign"/>
  <Transformation id="//T/R_/Move_/To_/Right" name="Move To Right" description="This transformation will move the selected item to the right so that it is exchanged with the item that follows it." keywords="Move" nodes="T_Action#T_Assign#T_Assignment#T_Call#T_Comment#T_Condition#T_Definition#T_Expression#T_Guarded#T_MW_Proc_Call#T_Proc_Call#T_Skip#T_Statement#T_Var_Lvalue#T_X_Proc_Call"/>
  <Transformation id="//T/R_/Partially_/Join_/Cases" name="Partially Join Cases" description="This transformation will join any guards in an If statement which contain almost the same sequence of statements (thus reducing their number) by introducing a nested If and changing the conditions of all the guards as appropriate." keywords="Rewrite Join" nodes="T_Comment#T_Cond"/>
  <Transformation id="//T/R_/Prog_/To_/Spec" name="Prog_To_Spec" description="Convert given program to an equivalent specification statement." keywords="Abstraction" nodes="T_Abort#T_Assert#T_Assignment#T_Comment#T_Cond#T_D_If#T_Prinflush#T_Print#T_Skip#T_Spec#T_Statement#T_Statements#T_Var"/>
  <Transformation id="//T/R_/Prune_/Dispatch" name="Prune Dispatch" description="Simplify the dispatch action by removing references to dest values which do not appear in the rest of the program." keywords="Simplify" nodes="T_A_S#T_Action#T_Cond#T_Negate#T_Number#T_Or#T_Statements"/>
  <Transformation id="//T/R_/Push_/Pop" name="Push Pop" description="Look for a statement sequence with a PUSH of a var followed by a POP of the same var. Put the sequence inside a VAR to show that the variable is unchanged." keywords="Rewrite" nodes="T_Pop#T_Push#T_Var"/>
  <Transformation id="//T/R_/Recursion_/To_/Loop" name="Recursion To Loop" description="Recursion To Loop will replace the body of a recursive action if possible by an equivalent loop structure." keywords="Rewrite" nodes="T_Action#T_Call#T_Proc#T_Proc_Call"/>
  <Transformation id="//T/R_/Reduce_/Loop" name="Reduce Loop" description="Automatically make the body of a DO...OD reducible (by introducing new procedures as necessary) and either remove the loop (if it is a dummy loop) or convert the loop to a WHILE loop (if the loop is a proper sequence)." keywords="Simplify" nodes="T_Floop"/>
  <Transformation id="//T/R_/Reduce_/Multiple_/Loops" name="Reduce Multiple Loops" description="This transformation will reduce the number of multiply nested loops to a minimum." keywords="Simplify" nodes="T_Floop"/>
  <Transformation id="//T/R_/Refine_/Spec" name="Refine_Spec" description="Refine a specification statement into something closer to an implementation" keywords="Refinement" nodes="T_Spec"/>
  <Transformation id="//T/R_/Remove_/Dummy_/Loop" name="Remove Dummy Loop" description="Remove Dummy Loop will remove a DO loop which is redundant" keywords="Simplify" nodes="T_Floop"/>
  <Transformation id="//T/R_/Remove_/Redundant_/Vars" name="Remove Redundant Vars" description="Remove Redundant Vars takes out as many local variables as possible from the selected VAR structure. If they can all be taken out, the VAR is replaced by its (possibly modified) body." keywords="Delete" nodes="T_MW_BFunct#T_MW_Funct#T_Statements#T_Var#T_Where#T_X_Proc_Call"/>
  <Transformation id="//T/R_/Rename_/Defns" name="Rename_Defns" description="Rename PROC definitions to avoid name clashes. This allows us to move all the definitions to a single outer WHERE clause." keywords="Rewrite" nodes="T_Where"/>
  <Transformation id="//T/R_/Rename_/Proc" name="Rename_Proc" description="Rename a PROC to given new name" keywords="Rewrite" nodes="T_Proc"/>
  <Transformation id="//T/R_/Replace_/Accs_/With_/Value" name="Replace Accs With Value" description="This transformation will apply Replace With Value to all variables with the names a0, a1, a2 and a3 in the selected item. " keywords="Rewrite" nodes=""/>
  <Transformation id="//T/R_/Replace_/With_/Value" name="Replace With Value" description="This transformation will replace a variable (in an expression) by its value -- provided that that value can be uniquely determined at that point in the program." keywords="Rewrite" nodes="T_Aref#T_Aref_Lvalue#T_Rel_Seg#T_Rel_Seg_Lvalue#T_Struct#T_Sub_Seg#T_Sub_Seg_Lvalue#T_Var_Lvalue#T_Variable"/>
  <Transformation id="//T/R_/Replace_/With_/Variable" name="Replace_With_Variable" description="This transformation will search for a variable which is assigned to the selected expression. If found, it will replace the expression with the variable." keywords="Rewrite" nodes="T_Expression"/>
  <Transformation id="//T/R_/Reverse_/Order" name="Reverse Order" description="This transformation will reverse the order of most two-component items; in particular expressions, conditions and Ifs which have two branches." keywords="Reorder" nodes="T_And#T_Assignment#T_Cond#T_Equal#T_Greater#T_Greater_Eq#T_If#T_Less#T_Less_Eq#T_Max#T_Min#T_Not_Equal#T_Or#T_Plus#T_Times"/>
  <Transformation id="//T/R_/Roll_/Loop" name="Roll_Loop" description="Roll the first step of a WHILE loop. " keywords="Rewrite" nodes="T_Cond"/>
  <Transformation id="//T/R_/Semantic_/Slice" name="Semantic_Slice" description="Perform Semantic Slicing on a subset of WSL. Enter the list of variables to slice on as the data parameter." keywords="Simplify" nodes="T_A_Proc_Call#T_Exit#T_Floop#T_For_In#T_Statement#T_Statements#T_Var_Lvalue#T_While"/>
  <Transformation id="//T/R_/Separate_/Both" name="Separate_Both" description="Separate Both will take code out to the right and the left of the selected structure." keywords="Reorder" nodes="T_Assignment#T_Cond"/>
  <Transformation id="//T/R_/Separate_/Exit_/Code" name="Separate_Exit_Code" description="Separate Exit Code will take exit code (code which must lead to termination of the loop) out of the loop, using a flag if necessary that indicates which exit from the loop was taken. " keywords="Reorder" nodes="T_Exit#T_Floop"/>
  <Transformation id="//T/R_/Separate_/Left" name="Separate_Left" description="Separate_Left will take code out to the left of the selected structure. As much code as possible will be taken out; if all the statements are taken out then the original containing structure will be removed" keywords="Reorder" nodes="T_Assignment#T_Cond#T_D_If#T_For#T_Funct_Call#T_MW_Funct_Call#T_MW_Proc_Call#T_Proc_Call#T_Skip#T_Var#T_Where#T_While#T_X_Funct_Call#T_X_Proc_Call"/>
  <Transformation id="//T/R_/Separate_/Right" name="Separate_Right" description="Separate_Right will take code out to the right of the selected structure." keywords="Reorder" nodes="T_Assignment#T_Cond#T_D_If#T_Floop#T_For#T_MW_Proc_Call#T_Proc_Call#T_Skip#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Simple_/Slice" name="Simple_Slice" description="Perform Simple Slicing on a subset of WSL. Enter the list of variables to slice on as the data parameter." keywords="Simplify" nodes="T_Abort#T_Assert#T_Assignment#T_Comment#T_Cond#T_D_If#T_Skip#T_Spec#T_Statement#T_Statements#T_Var#T_Var_Lvalue#T_While"/>
  <Transformation id="//T/R_/Simplify_/Action_/System" name="Simplify Action System" description="Simplify action system will attempt to remove actions and calls from an action system by successively applying simplifying transformations. As many of the actions as possible will be eliminated without making the program significantly larger." keywords="Simplify" nodes="T_A_S"/>
  <Transformation id="//T/R_/Simplify" name="Simplify" description="This transformation will simplify any component as fully as possible." keywords="Simplify " nodes=""/>
  <Transformation id="//T/R_/Simplify_/If" name="Simplify If" description="Simplify If will remove false cases from an IF statement, and any cases whose conditions imply earlier conditions. Any repeated statements which can be taken outside the if will be, and the conditions will be simplified if possible." keywords="Simplify" nodes="T_Comment#T_Cond#T_False#T_Not_Equal#T_True"/>
  <Transformation id="//T/R_/Simplify_/Item" name="Simplify Item" description="This transformation will simplify an item, but not recursively simplify the components inside it.  In particular, the transformation will simplify expressions, conditions and degenerate conditional, local variable and loop statements." keywords="Simplify " nodes="T_A_S#T_Assert#T_Assign#T_Assignment#T_Cond#T_Condition#T_D_If#T_Expression#T_False#T_Floop#T_Guarded#T_True#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Sort_/Procs" name="Sort_Procs" description="Sort the order of procs in a WHERE so that:   (a) A proc appears after _all_ the procs which call it, and    (b) Secondary ordering is via a depth-first search of the call graph: ie via the order in which proc calls are encountered in a depth-first scan. " keywords="Rewrite" nodes="T_Where"/>
  <Transformation id="//T/R_/Stack_/To_/Par" name="Stack_To_Par" description="Convert stack references to a procedure parameter" keywords="Simplify " nodes="T_Pop#T_Proc#T_Proc_Call#T_Push#T_Var#T_Where"/>
  <Transformation id="//T/R_/Stack_/To_/Var" name="Stack_To_Var" description="Convert a stack PUSH/POP pair to a local variable" keywords="Simplify " nodes="T_Pop#T_Push#T_Statements#T_Variable"/>
  <Transformation id="//T/R_/Static_/Single_/Assignment" name="Static_Single_Assignment" description="Convert WSL code to Static Single Assignment form by renaming variables and adding phi function assignments." keywords="Rewrite" nodes="T_For#T_Var#T_Where#T_X_Funct_Call"/>
  <Transformation id="//T/R_/Substitute_/And_/Delete" name="Substitute and Delete" description="Substitute and Delete will replace all calls to an action, procedure or function with the corresponding definition, and delete the definition" keywords="Rewrite" nodes="T_Action#T_Funct#T_Proc"/>
  <Transformation id="//T/R_/Substitute_/And_/Delete_/List" name="Substitute and Delete List" description="Substitute and Delete List will replace all calls to any action within the selected list of actions with the corresponding definition and delete the definition. Actions which are called more than  once will not be affected." keywords="Rewrite" nodes="T_Action"/>
  <Transformation id="//T/R_/Syntactic_/Slice" name="Syntactic_Slice" description="Perform Syntactic Slicing using SSA and control dependencies. Enter the list of variables to slice on as the data parameter." keywords="Simplify" nodes="T_Statements"/>
  <Transformation id="//T/R_/Take_/Out_/Left" name="Take Out Left" description="This transformation will take the selected item out of the enclosing structure towards the left." keywords="Move" nodes="T_Assign#T_D_Do#T_Floop#T_For#T_Guarded#T_Statement#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Take_/Out_/Of_/Loop" name="Take Out Of Loop" description="This transformation will take the selected item out of an appropriate enclosing loop towards the right." keywords="Move" nodes="T_Assign#T_Statement"/>
  <Transformation id="//T/R_/Take_/Out_/Right" name="Take Out Right" description="This transformation will take the selected item out of the enclosing structure towards the right." keywords="Move" nodes="T_Assign#T_D_Do#T_For#T_Guarded#T_Statement#T_Var#T_Where#T_While"/>
  <Transformation id="//T/R_/Unfold_/Proc_/Call" name="Unfold Proc Call" description="Unfold the selected procedure call, replacing it with a copy of the procedure body." keywords="Rewrite" nodes="T_Proc_Call"/>
  <Transformation id="//T/R_/Unfold_/Proc_/Calls" name="Unfold Proc Calls" description="Unfold Proc Calls searches for procedures which are only called once, unfolds the call and removes the procedure." keywords="Simplify" nodes="T_Proc#T_Where"/>
  <Transformation id="//T/R_/Unroll_/Loop" name="Unroll_Loop" description="Unroll the first step of a WHILE loop. " keywords="Rewrite" nodes="T_Floop#T_While"/>
  <Transformation id="//T/R_/Use_/Assertion" name="Use_Assertion" description="Use the currently selected assertion to simplify code." keywords="Use/Apply" nodes="T_Assert"/>
  <Transformation id="//T/R_/Var_/Pars_/To_/Val_/Pars" name="Var_Pars_To_Val_Pars" description="Add all VAR pars as extra value pars where needed. This is needed by the SSA transformation so that the input and output parameters can get different names." keywords="Rewrite" nodes="T_Where"/>
  <Transformation id="//T/R_/While_/To_/Abort" name="While_To_Abort" description="This transformation replaces a non-terminating while loop with a conditional abort" keywords="Simplify " nodes="T_While"/>
  <Transformation id="//T/R_/While_/To_/Floop" name="While To Floop" description="Convert any WHILE loop to a DO...OD loop " keywords="Rewrite" nodes="T_While"/>
  <Transformation id="//T/R_/While_/To_/For_/In" name="While_To_For_In" description="Replace a WHILE loop with an equivalent FOR x IN y loop" keywords="Simplify " nodes="T_Statements#T_While"/>
  <Transformation id="//T/R_/While_/To_/Reduce" name="While_To_Reduce" description="Replace a WHILE loop with an equivalent REDUCE or MAP" keywords="Simplify " nodes="T_Assert#T_While"/>
</TransformationTable>
