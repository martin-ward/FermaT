C:"
==========================================================================
FermaT Transformation System
Copyright (C) 2001 Software Migrations Limited.
Email: martin@gkc.org.uk

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
==========================================================================";

C:" WSL to Scheme Translator ";
C:" Keep track of the indentation, start a newline after each statement. ";

C:" NOTE: Scheme itself is NOT case-dependent while WSL is case-dependent ";
C:" So we need to rename the WSL variable names to distinguish cases ";
C:" (and avoid clashes with vars generated by the translator) ";

WSL_Option_Quiet := 0;

C:" Current nesting level (1 = top level): ";
WS_Nesting := 1;
C:" Indentation for each level of nesting: ";
WS_Indents := ARRAY(1999, 0);
C:" Current position of cursor (number of chars on line): ";
WS_X_Pos := 0;
C:" A flag to record whether the indent for this line has been printed yet: ";
WS_Indent_Pending := 0;

Spaces := "                                                             ";

ws_macro_pars := < >;

C:" Write a string, keep a record of the position of each open bracket ";
C:" and the level of bracket nesting. ";
C:" Update the indents _before_ printing the indent for this line: ";

MW_PROC @WSS(str) ==
  VAR < i := 0, closes := 0, quote := 0, comment := 0 >:
  C:" If there are pending indents, adjust the indent according to the number ";
  C:" of initial )'s, then print the indent and continue: ";
  IF WS_Indent_Pending = 1
    THEN WHILE i < SLENGTH(str) AND SUBSTR(str, i, 1) = ")" DO
	   closes := closes + 1; i := i + 1 OD;
	   C:" Calculate the actual indent and print it: ";
	   IF WS_Nesting - closes < 1
	     THEN ERROR("@WSS", "Too many closing brackets", str) FI;
	   WS_X_Pos := WS_Indents[WS_Nesting - closes] MOD 40;
	   @Write(SUBSTR(Spaces, 0, WS_X_Pos), Output_Port);
	   WS_Indent_Pending := 0 FI;
  FOR i := 0 TO SLENGTH(str) - 1 STEP 1 DO
    IF SUBSTR(str, i, 1) = Quote
      THEN quote := 1 - quote
    ELSIF SUBSTR(str, i, 1) = ";"
      THEN comment := 1 FI;
    IF comment = 0 AND quote = 0
      THEN IF SUBSTR(str, i, 1) = "("
	     THEN WS_Nesting := WS_Nesting + 1;
		  WS_Indents[WS_Nesting] := WS_X_Pos + i + 1
	   ELSIF SUBSTR(str, i, 1) = ")"
	     THEN IF WS_Nesting <= 1
		    THEN ERROR("@WSS", "Too many closing brackets", str) FI;
		  WS_Nesting := WS_Nesting - 1 FI FI OD;
  @Write(str, Output_Port);
  WS_X_Pos := WS_X_Pos + SLENGTH(str) ENDVAR .;


C:" Start a newline and indent to the appropriate level: ";

MW_PROC @WSSL(str) ==
  @WSS(str);
  @Write_Line("", Output_Port);
  WS_Indent_Pending := 1 .;



C:" Initialisation section: ";

fl_flag1 := 0;
fl_flag2 := 0;
fl_flag3 := 0;
fl_flag4 := 0;
fl_flag5 := 0;
fl_flag6 := 0;
fl_flag7 := 0;
fl_flag8 := 0;
fl_flag9 := 0;
fl_flagX := 0;

VAR < type := 0 >:

  C:" Types which can be translated as (funct par1 par2 ...), the default type ";
  Scheme_Funct := 1;

  C:" Types which can be translated as funct++value ";
  Scheme_Literal := 2;

  C:" Proc or Funct call types, may have value and VAR parameters: ";
  Scheme_Call := 3;

  C:" Proc or Funct declaration: ";
  Scheme_Decl := 4;

  C:" Some kind of IFMATCH: ";
  Scheme_Ifmatch := 5;

  C:" Some kind of FILL: ";
  Scheme_Fill := 6;

  C:" Special cases ";
  Scheme_Special := 99;

  WS_Type  := ARRAY(1999, Scheme_Funct);
  WS_Funct := ARRAY(1999, "");

  C:" Data for each type: ";

  WS_Type[T_Statements]		:= Scheme_Special;

  WS_Funct[T_Expressions]	:= "";
  WS_Funct[T_Lvalues]		:= "";
  WS_Funct[T_Assigns] 		:= "";
  WS_Funct[T_Definitions]	:= "";
  WS_Funct[T_Assign]		:= "";
  WS_Funct[T_Guarded]		:= "";
  WS_Funct[T_Abort]		:= "abort";

  WS_Type[T_Skip] 		:= Scheme_Literal;
  WS_Type[T_True] 		:= Scheme_Literal;
  WS_Type[T_False] 		:= Scheme_Literal;
  WS_Funct[T_Skip]		:= "#t";
  WS_Funct[T_True]		:= "#t";
  WS_Funct[T_False]		:= "#f";

  C:" TODO: make-hash-table requires a size parameter for the array. ";
  C:" ??? Write our own hash code to double the size of a table ";
  C:" when it gets `too full' ??? ";

  WS_Funct[T_Hash_Table]	:= "make-hash-table";

  WS_Funct[T_Slength]		:= "string-length";
  WS_Funct[T_Substr]		:= "substr";
  WS_Funct[T_Index]		:= "my-index";


  FOR type IN <T_Expn_Place, T_Var_Place, T_Cond_Place, T_Stat_Place> DO
    WS_Type[type] := Scheme_Literal OD;

  WS_Funct[T_Expn_Place]	:= "$Expn$";
  WS_Funct[T_Var_Place]		:= "$Var$";
  WS_Funct[T_Cond_Place]	:= "$Condition$";
  WS_Funct[T_Stat_Place]	:= "$Statement$";

  FOR type IN <T_Stat_Pat_One, T_Expn_Pat_One, T_Cond_Pat_One,
	       T_Defn_Pat_One, T_Lvalue_Pat_One, T_Assign_Pat_One,
	       T_Guarded_Pat_One, T_Action_Pat_One, T_Name_Pat_One> DO
    WS_Type[type]  := Scheme_Literal;
    WS_Funct[type] := "~?" OD;

  FOR type IN <T_Stat_Pat_Many, T_Expn_Pat_Many, T_Cond_Pat_Many,
	       T_Defn_Pat_Many, T_Lvalue_Pat_Many, T_Assign_Pat_Many,
	       T_Guarded_Pat_Many, T_Action_Pat_Many> DO
    WS_Type[type]  := Scheme_Literal;
    WS_Funct[type] := "~+" OD;

  FOR type IN <T_Stat_Pat_Any, T_Expn_Pat_Any, T_Cond_Pat_Any,
	       T_Defn_Pat_Any, T_Lvalue_Pat_Any, T_Assign_Pat_Any,
	       T_Guarded_Pat_Any, T_Action_Pat_Any> DO
    WS_Type[type]  := Scheme_Literal;
    WS_Funct[type] := "~*" OD;

  FOR type IN <T_Proc_Call,
	       T_A_Proc_Call, T_MW_Proc_Call, T_X_Proc_Call,
	       T_X_Funct_Call, T_MW_Funct_Call, T_Funct_Call,
	       T_X_BFunct_Call, T_MW_BFunct_Call, T_BFunct_Call> DO
    WS_Type[type]  := Scheme_Call OD;

  WS_Funct[T_Print]		:= "display-list";
  WS_Funct[T_Prinflush]		:= "display-list-flush";

  WS_Funct[T_Maphash]		:= "maphash ";
  WS_Funct[T_Error]		:= "error";

  WS_Funct[T_Assert]		:= "assertion";

  WS_Type[T_Assignment] 	:= Scheme_Special;
  WS_Type[T_A_S] 		:= Scheme_Special;
  WS_Type[T_Call]		:= Scheme_Special;

  WS_Funct[T_Action]		:= "";

  WS_Type[T_Comment]		:= Scheme_Special;
  WS_Type[T_Cond]		:= Scheme_Special;
  WS_Type[T_D_If]		:= Scheme_Special;
  WS_Type[T_D_Do]		:= Scheme_Special;
  WS_Type[T_Exit]		:= Scheme_Special;
  WS_Type[T_For]		:= Scheme_Special;
  WS_Type[T_For_In]		:= Scheme_Special;

  WS_Funct[T_Foreach_Stat]	:= "@Foreach_Statement";
  WS_Funct[T_Foreach_NAS]	:= "@Foreach_Non_Action_Statement";
  WS_Funct[T_Foreach_Stats]	:= "@Foreach_Stats";
  WS_Funct[T_Foreach_TS]	:= "@Foreach_Terminal";
  WS_Funct[T_Foreach_TSs]	:= "@Foreach_Terminal_Stats";
  WS_Funct[T_Foreach_STS]	:= "@Foreach_Terminal";
  WS_Funct[T_Foreach_Cond]	:= "@Foreach_Cond";
  WS_Funct[T_Foreach_Expn]	:= "@Foreach_Expn";
  WS_Funct[T_Foreach_Lvalue]	:= "@Foreach_Lvalue";
  WS_Funct[T_Foreach_Variable]	:= "@Foreach_Variable";
  WS_Funct[T_Foreach_Global_Var]:= "@Foreach_Global_Var";

  WS_Funct[T_Ateach_Stat]	:= "@Ateach_Statement";
  WS_Funct[T_Ateach_NAS]	:= "@Ateach_Non_Action_Statement";
  WS_Funct[T_Ateach_Stats]	:= "@Ateach_Stats";
  WS_Funct[T_Ateach_TS]		:= "@Ateach_Terminal";
  WS_Funct[T_Ateach_TSs]	:= "@Ateach_Terminal_Stats";
  WS_Funct[T_Ateach_STS]	:= "@Ateach_Terminal";
  WS_Funct[T_Ateach_Cond]	:= "@Ateach_Cond";
  WS_Funct[T_Ateach_Expn]	:= "@Ateach_Expn";
  WS_Funct[T_Ateach_Lvalue]	:= "@Ateach_Lvalue";
  WS_Funct[T_Ateach_Variable]	:= "@Ateach_Variable";
  WS_Funct[T_Ateach_Global_Var]	:= "@Ateach_Global_Var";

  C:" Note: we need to keep track of the current depth for Floop and Exit: ";
  WS_Type[T_Floop]		:= Scheme_Special;

  WS_Funct[T_Join]		:= "join";
  WS_Funct[T_Pop]		:= "pop";
  WS_Funct[T_Puthash]		:= "puthash";

  WS_Funct[T_Push]		:= "push";
  WS_Funct[T_Spec]		:= "spec-stat";

  C:" Save the global values and overwrite with the assignments: ";
  C:" (This is needed to get dynamic binding to work) ";
  WS_Type[T_Var]		:= Scheme_Special;

  WS_Type[T_Where]		:= Scheme_Special;

  WS_Funct[T_While]		:= "while";


  FOR type IN <T_Proc, T_Funct, T_BFunct,
	       T_MW_Proc, T_MW_Funct, T_MW_BFunct> DO
    WS_Type[type] := Scheme_Decl OD;


  FOR type IN <T_Ifmatch_Stat, T_Ifmatch_Expn, T_Ifmatch_Cond, T_Ifmatch_Defn,
	       T_Ifmatch_Lvalue, T_Ifmatch_Assign,
	       T_Ifmatch_Guarded, T_Ifmatch_Action,
	       T_Ifmatch_Stats, T_Ifmatch_Expns, T_Ifmatch_Lvalues,
	       T_Ifmatch_Assigns, T_Ifmatch_Defns> DO
    WS_Type[type] := Scheme_Ifmatch OD;


  C:" Generic type: Expression ";

  WS_Funct[T_Get_n]		:= "@Get_n";
  WS_Funct[T_Get]		:= "@Get";
  WS_Funct[T_Gethash]		:= "gethash";
  WS_Funct[T_Hash_Table]	:= "hash-table";


  FOR type IN <T_Number, T_Variable> DO
    WS_Type[type]  := Scheme_Literal OD;


  WS_Type[T_String]		:= Scheme_Special;
  WS_Type[T_Sequence]		:= Scheme_Special;
  WS_Type[T_Aref]		:= Scheme_Special;

  WS_Funct[T_Sub_Seg]		:= "@Sub_Seg";
  WS_Funct[T_Rel_Seg]		:= "@Rel_Seg";
  WS_Funct[T_Final_Seg]		:= "@Final_Seg";
  WS_Funct[T_Map]		:= "my-map ";
  WS_Funct[T_Reduce]		:= "my-reduce ";
  WS_Funct[T_Plus]		:= "+";
  WS_Funct[T_Minus]		:= "-";
  WS_Funct[T_Times]		:= "*";
  WS_Funct[T_Divide]		:= "/";

  WS_Funct[T_Exponent]		:= "integer-expt";
  WS_Funct[T_Mod]		:= "modulo";
  WS_Funct[T_Div]		:= "quotient";
  WS_Funct[T_If]		:= "if";
  WS_Funct[T_Abs]		:= "abs";
  WS_Funct[T_Frac]		:= "frac";
  WS_Funct[T_Int]		:= "int";
  WS_Funct[T_Sgn]		:= "sgn";
  WS_Funct[T_Max]		:= "max";
  WS_Funct[T_Min]		:= "min";

  C:" NOTE: slib has an implementation of `balanced binary trees' ";
  C:" which includes efficient set operations. ";

  WS_Funct[T_Intersection]	:= "intersection-n";
  WS_Funct[T_Union]		:= "union-n";
  WS_Funct[T_Set_Diff]		:= "@Set_Difference";
  WS_Funct[T_Powerset]		:= "@Powerset";
  WS_Funct[T_Set]		:= "set-construction";
  WS_Funct[T_Array]		:= "make-vector-eval"; C:" was: make-vector-eval ";
  WS_Funct[T_Head]		:= "car";
  WS_Funct[T_Tail]		:= "cdr";
  WS_Funct[T_Last]		:= "last-1";
  WS_Funct[T_Butlast]		:= "butlast-1";
  WS_Funct[T_Length]		:= "gen-length";
  WS_Funct[T_Reverse]		:= "reverse";
  WS_Funct[T_Concat]		:= "concat";

  C:" Dummy functions for unimplemented features: ";

  WS_Funct[T_Address_Of]        := "address-of";
  WS_Funct[T_Mem]               := "memory-access";
  WS_Funct[T_Mem_Lvalue]        := "memory-access-lvalue";
  WS_Funct[T_Mem_Seg]           := "memory-access-seg";
  WS_Funct[T_Mem_Seg_Lvalue]    := "memory-access-seg-lvalue";
  WS_Funct[T_Mem_Rel]           := "memory-access-rel";
  WS_Funct[T_Mem_Rel_Lvalue]    := "memory-access-rel-lvalue";
  

  WS_Funct[T_Negate]		:= "-";
  WS_Funct[T_Invert]		:= "/";

  WS_Type[T_Struct]		:= Scheme_Special;

  FOR type IN <T_Fill_Stat,  T_Fill_Expn,  T_Fill_Cond,  T_Fill_Defn,
	       T_Fill_Stats, T_Fill_Expns, T_Fill_Defns,
	       T_Fill_Lvalue, T_Fill_Lvalues,
	       T_Fill_Assign, T_Fill_Guarded, T_Fill_Action,
	       T_Fill_Assigns, T_Fill_Defns> DO
    WS_Type[type] := Scheme_Fill OD;


  C:" Generic Type: Condition ";

  WS_Funct[T_And]		:= "and";
  WS_Funct[T_Or]		:= "or";
  WS_Funct[T_Not]		:= "not";

  C:" Use eq? for atoms, = for numbers and equal? for anything else (or unknown) ";
  WS_Type[T_Equal]		:= Scheme_Special;
  WS_Type[T_Not_Equal]		:= Scheme_Special;

  WS_Funct[T_Less]		:= "<";
  WS_Funct[T_Greater]		:= ">";
  WS_Funct[T_Less_Eq]		:= "<=";
  WS_Funct[T_Greater_Eq]	:= ">=";
  WS_Funct[T_Even]		:= "even?";
  WS_Funct[T_Odd]		:= "odd?";
  WS_Funct[T_Empty]		:= "null?";
  WS_Funct[T_Subset]		:= "@Set_Subset?";
  WS_Funct[T_Member]		:= "member";
  WS_Funct[T_In]		:= "member";
  WS_Funct[T_Not_In]		:= "not-member";
  WS_Funct[T_Forall]		:= "forall";
  WS_Funct[T_Exists]		:= "exists";
  WS_Funct[T_Implies]		:= "implies";
  WS_Funct[T_Sequenceq]		:= "sequence?";
  WS_Funct[T_Numberq]		:= "number?";
  WS_Funct[T_Stringq]		:= "string?";


  C:" Generic Type: Definition (see above) -- Scheme_Decl ";

  C:" Generic_Type: Lvalue ";

  WS_Type[T_Var_Lvalue]		:= Scheme_Literal;
  WS_Funct[T_Var_Lvalue]	:= "";

  C:" Arefs, Sub_Segs, Rel_Segs and Final_Segs should all have been ";
  C:" translated higher up in the WSL tree (in the translation of ";
  C:" the assignment or whatever), so these function should not be called: ";

  WS_Funct[T_Aref_Lvalue]	:= "@Aref_Lvalue";
  WS_Funct[T_Sub_Seg_Lvalue]	:= "@Sub_Seg_Lvalue";
  WS_Funct[T_Rel_Seg_Lvalue]	:= "@Rel_Seg_Lvalue";
  WS_Funct[T_Final_Seg_Lvalue]	:= "@Final_Seg_Lvalue";

  WS_Type[T_Struct_Lvalue]	:= Scheme_Special;

  C:" End of WS_Init " ENDVAR;



MW_PROC @WSL_To_Scheme(I, Filename, Input) ==
  VAR < Globals := < >, floop_depth := 0, z_name := @Make_Name("Z"), 
	m_one := @Make(T_Number, -1, < >), 
	make_n := @Make(T_Name, @Make_Name("@Make"), < >),
	make_name := @Make_Name("@Make_Name"),
	tmp_result := @Make_Name("-result-"),
	tmp_var := "tmp-var", funct_result := "funct-result", 
	Call_Types := <T_Proc_Call, T_Funct_Call, T_BFunct_Call,
		       T_MW_Proc_Call, T_MW_Funct_Call, T_MW_BFunct_Call,
		       T_X_Proc_Call, T_X_Funct_Call, T_X_BFunct_Call>,
	Macros := MAP("@Make_Name",
		      <"@Size", "@Get_n", "@Spec_Type", "@ST",
		       "@Gen_Type", "@GT", "@Value", "@V", "@Components", "@Cs",
		       "@Components?", "@Cs?", "@Program", "@Item", "@I",
		       "@Parent", "@GParent", "@Posn", "@Posn_n", "@Data",
		       "@Buffer", "@Make", "@Right?", "@Right", "@Left?", "@Left",
		       "@Up?", "@Up", "@Down?", "@Down", "@Down_Last",
		       "@To", "@To_Last", "@Down_To",
		       "@Cut", "@New_Program",
		       "@Dtable_Get", "@Dtable_Value_Part", "@Dtable_Put",
		       "@String", "@Make_Name">) >:

  C:" Macros are currently broken: ";
  Macros := < >;

  C:" Initial Simplification Transformations: ";
  @Edit;
  @New_Program(I);

  C:" TODO: Simplify `simple' IFMATCH constructs to a nested IF which ";
  C:" sets a local Match_Result variable and the pattern variables ";

  FOREACH Statement DO
    IF @Ifmatch_Type?(@ST(@I))
      THEN @Trans(TR_Ifmatch_Processing, "") FI OD;

  FOREACH Expression DO
    IFMATCH Expression REDUCE("++", ~?e)
      THEN @Paste_Over(FILL Expression REDUCE("concat", ~?e) ENDFILL) ENDMATCH OD;

  C:" pop macro does not handle complex variables eg arrays ";
  C:" So convert POP to the equivalent assignment statements: ";
  FOREACH Statement DO
    IFMATCH Statement POP(~?v, ~?stack)
      THEN @Splice_Over(<FILL Statement ~?v := HEAD(~?stack) ENDFILL,
                         FILL Statement ~?stack := TAIL(~?stack) ENDFILL>) ENDMATCH OD;

  C:" (- a b ...) is only optional in R5RS, scheme48 only has two argument minus: ";

  FOREACH Expression DO
    IF @ST(@I) = T_Minus AND @Size(@I) > 2
      THEN @Paste_Over(@Make(T_Minus, < >,
                             <@I^1, @Make(T_Plus, < >, TAIL(@Cs(@I)))>)) FI OD;

  C:" Replace constant FILL constructs by global variables. ";
  C:" This should be done _after_ Ifmatch_Processing! ";
  C:" Ditto for @Make_Name calls with a string parameter by global variables. ";

  VAR < inits := < >, name := "%const__" ++ Input ++ "__", n := 0, v := < >,
        make_name := @Make_Name("@Make_Name") >:
  FOREACH Expression DO 
    IF @Fill_Type?(@ST(@I)) AND @WS_Constant_Fill?(@I)
         OR FALSE AND @ST(@I) = T_MW_Funct_Call AND @V(@I^1) = make_name
	      AND @ST(@I^2^1) = T_String
      THEN v := < >;
           FOR init IN inits DO
             IF @Equal?(init^2, @I)
               THEN v := init^1 FI OD;
           IF EMPTY?(v)
             THEN n := n + 1;
                  v := @Make(T_Var_Lvalue, @Make_Name(name ++ @String(n)), < >);
                  inits := <@Make(T_Assign, < >, <v, @I>)> ++ inits FI;
           @Paste_Over(@Lvalue_To_Expn(v)) FI OD;
  IF NOT EMPTY?(inits)
    THEN @Down;
         @Paste_Before(@Make(T_Assignment, < >, REVERSE(inits)));
	 @Up FI ENDVAR;



  C:"  Check for array references and assignments on known array variables ";
  C:" (and other global vars which are known to be arrays) ";
  C:" and convert to !XF vector-ref(name, index - 1) and ";
  C:" !XP vector-set! (name, index - 1, value) as appropriate ";

  VAR < arrays := MAP("@Make_Name", <"Eval_Op", "Has_Statements",
         "Identity_Value", "Inverse_Op", "Mth_Ord", "N_String_To_Symbol",
         "N_Symbol_Table", "N_Symbol_Table_Length", "PP_Closing",
         "PP_Indent", "PP_Opening", "PP_Operator", "PP_Operator1",
         "PP_Operator2", "PP_Prec", "PP_Split", "PP_Sub_Indent", "PP_Type",
         "Power_Op", "Reverse_Op", "Spec_To_Gen_Type", "Syntax_Comps",
         "Syntax_E_To_V", "Syntax_Name", "Syntax_Type", "Syntax_V_To_E",
         "Syntax_Value", "TRs_Code", "TRs_Data_Gen_Type", "TRs_Help",
         "TRs_Keywords", "TRs_Name", "TRs_Proc_Name", "TRs_Prompt",
         "TRs_Test", "WS_Funct", "WS_Indents", "WS_Type", "Zero_Value",
         "__Match_array", "orig_Bodies", "orig_Entries">),
        ref := @Name(@Make_Name("vector-ref")),
	set := @Name(@Make_Name("vector-set!")) >:

  FOREACH Expression DO
    IFMATCH Expression ~?v[~?e]
      THEN IF @ST(v) = T_Variable AND @V(v) IN arrays
             THEN e := @Simplify_Expn(FILL Expression ~?e - 1 ENDFILL);
                  @Paste_Over(@Make(T_X_Funct_Call, < >,
		                    <ref, @Make(T_Expressions, < >,
				                <v, e>)>))  FI ENDMATCH OD;

  FOREACH Statement DO
    IFMATCH Statement ~?v[~?e] := ~?e1
      THEN IF @ST(v) = T_Var_Lvalue AND @V(v) IN arrays
             THEN e := @Simplify_Expn(FILL Expression ~?e - 1 ENDFILL);
	          v := @Lvalue_To_Expn(v);
                  @Paste_Over(@Make(T_X_Proc_Call, < >,
		                <set, @Make(T_Expressions, < >,
                                            <v, e, e1>)>))  FI ENDMATCH OD ENDVAR;


  C:" Replace concat by either cons or string-append: ";
  VAR < args := < >, arg := < >, rest := < >, new := < >,
	cons := @Make_Name("cons"), string_append := @Make_Name("string-append") >:
  C:" Flatten nested concats (from the inside out): ";
  C:" Check for prepending sequences: ";
  FOREACH Expression DO
    IF @ST(@I) = T_Concat AND @ST(@I^1) = T_Sequence AND @Size(@I) > 1
      THEN args := < >; rest := @Cs(@I);
	   WHILE NOT EMPTY?(rest) AND @ST(HEAD(rest)) = T_Sequence DO
	     args := REVERSE(@Cs(HEAD(rest)^1)) ++ args;
	     rest := TAIL(rest) OD;
	   IF LENGTH(rest) = 0
	     THEN @Paste_Over(@Make(T_Sequence, < >,
				    <@Make(T_Expressions, < >, REVERSE(args))>))
	     ELSE IF LENGTH(rest) = 1
		    THEN rest := HEAD(rest)
		    ELSE rest := @Make(T_Concat, < >, rest) FI;
		  C:" cons args to front of rest: ";
		  FOR arg IN args DO
		    rest := @Make_Funct(cons, <arg, rest>) OD;
		  @Paste_Over(rest) FI
    ELSIF @ST(@I) = T_Concat AND @Size(@I) > 1
	   AND (@ST(@I^1) = T_String OR @ST(@I^2) = T_String)
      THEN @Paste_Over(@Make_Funct(string_append, @Cs(@I))) FI OD ENDVAR;

  C:" Ensure remaining concats have two arguments each: ";
  VAR < arg1 := < > >:
  FOREACH Expression DO
    IF @ST(@I) = T_Concat
      THEN IF @Size(@I) = 0
	     THEN @Paste_Over(@Make(T_String, "", < >))
	   ELSIF @Size(@I) = 1
	     THEN @Paste_Over(@I^1)
	     ELSE WHILE @ST(@I) = T_Concat AND @Size(@I) > 2 DO
		    C:" combine first two arguments: ";
		    arg1 := @Make(T_Concat, < >, <@I^1, @I^2>);
		    @Down;
		    @Delete;
		    @Paste_Over(arg1);
		    @Up OD FI FI OD ENDVAR;

  C:" Delete calls to @yy_PRINT -- these are for debugging only ";
  VAR < yy_print := @Make_Name("@yy_PRINT") >:
  FOREACH Statement DO
    IF @ST(@I) = T_MW_Proc_Call AND @V(@I^1) = yy_print
      THEN @Delete FI OD ENDVAR;


  C:" Eliminate Floops where possible. ";
  C:" Note that we call TR_Floop_To_While without testing it: ";
  C:" This may result in copying code to eliminate the Floop. ";
  VAR < AS := @AS_Type, floop := 0, var := < > >:
  FOREACH Statement DO
    IF @ST(@I) = T_Floop AND @Trans?(TR_Floop_To_While)
      THEN C:" Check for a single EXIT at the top level: ";
	   floop := 1;
	   @Down;
	   IFMATCH Statements ~*S1; IF ~?B THEN ~*S; EXIT(1) FI; ~*S2
	     THEN @Up;
		  IF @Gen_Proper?(@Make(T_Statements, < >, S1 ++ S ++ S2), AS)
		    THEN B := @Not(B);
			 @Splice_Over(@Cs(FILL Statements
					  ~*S1; WHILE ~?B DO ~*S2; ~*S1 OD; ~*S ENDFILL))
		    ELSE @Trans(TR_Floop_To_While, "") FI
	     ELSE @Up; @Trans(TR_Floop_To_While, "") ENDMATCH FI OD ENDVAR;



  C:" Try to determine types of variables and simplify array refs etc. ";

  C:" Anything compared against a S_, TR_xxx, T_xxx, @ST, @GT, @Size ";
  C:" or any arithmetic expression is numeric. ";
  C:" A variable initialised by foo := ARRAY(...) is an array. ";

  VAR < Num_Var_Types := HASH_TABLE, Num_Funct_Types := HASH_TABLE,
	Num_Types := HASH_TABLE >:

  IF Input IN <"cond_parser", "exp_parser", "lexer", "parser">
    THEN Num_Var_Types.(@Make_Name("token1")) := 1 FI;
  Num_Var_Types.(@Make_Name("ST")) := 1;
  Num_Var_Types.(@Make_Name("GT")) := 1;
  FOR var IN @Variables(@I) DO
    IF @Starts_With?(var, "T_") OR @Starts_With?(var, "TR_")
      THEN Num_Var_Types.(var) := 1 FI OD;

  FOR name IN MAP("@Make_Name", <"@ST", "@GT", "@Size", "@Posn_n">) DO
    Num_Funct_Types.(name) := 1 OD;

  FOR type IN <T_Plus, T_Minus, T_Times, T_Divide, T_Exponent,
	       T_Max, T_Min, T_Number, T_Length, T_Slength> DO
    Num_Types.(type) := 1 OD;

  C:" Replace foo IN <x1, ...> by foo = x1 OR ... ";
  VAR < comps := < > >:
  FOREACH Condition DO
    IF @ST(@I) = T_In AND @ST(@I^2) = T_Sequence
      THEN comps := < >;
	   FOR elt IN @Cs(@I^2^1) DO
	     comps := <@Make(T_Equal, < >, <@I^1, elt>)> ++ comps OD;
	   @Paste_Over(@Make(T_Or, < >, REVERSE(comps)))
    ELSIF @ST(@I) = T_Not_In AND @ST(@I^2) = T_Sequence
      THEN comps := < >;
	   FOR elt IN @Cs(@I^2^1) DO
	     comps := <@Make(T_Not_Equal, < >, <@I^1, elt>)> ++ comps OD;
	   @Paste_Over(@Make(T_And, < >, REVERSE(comps))) FI OD ENDVAR;



  C:" Hack for tests of the form: NOT (EMPTY?(HEAD(x))) AND NOT EMPTY?(x) ";
  C:" Only fiddle with the condition if it may have been simplified by FermaT ";

  FOREACH Condition DO
    IF (@ST(@I) = T_And OR @ST(@I) = T_Or)
	 AND (T_Head IN @Spec_Types(@I) AND T_Empty IN @Spec_Types(@I)
	       OR T_Get_n IN @Spec_Types(@I))
         AND @Size(@I) > 1
	 AND @Equal?(@I, @Simplify_Cond(@I))
      THEN @Paste_Over(@Make(@ST(@I), < >, REVERSE(@Cs(@I))));
           IF T_Head IN @Spec_Types(@I^1) AND T_Head NOTIN @Spec_Types(@I^2)
	     THEN @Paste_Over(@Make(@ST(@I), < >,
	                            <@I^2, @I^1> ++ TAIL(TAIL(@Cs(@I)))))
           ELSIF T_Get_n IN @Spec_Types(@I^1) AND T_Get_n NOTIN @Spec_Types(@I^2)
	     THEN @Paste_Over(@Make(@ST(@I), < >,
	                            <@I^2, @I^1> ++ TAIL(TAIL(@Cs(@I))))) FI FI OD;


  C:" Fix REDUCE on /\ and \/ functions: ";
  VAR < union1 := @Make_Name(Backslash ++ "/"),
        union2 := @Make_Name(Backslash ++ Backslash ++ "/"),
        new_union := @Make_Name("@Set_Union"),
        intersect1 := @Make_Name("/" ++ Backslash),
	intersect2 := @Make_Name("/" ++ Backslash ++ Backslash),
	new_intersect := @Make_Name("@Set_Intersect") >:
  FOREACH Expression DO
    IF @ST(@I) = T_Reduce
      THEN @Down;
           IF @V(@I) = union1 OR @V(@I) = union2
	     THEN @Paste_Over(@Make(T_Name, new_union, < >))
           ELSIF @V(@I) = intersect1 OR @V(@I) = intersect2
	     THEN @Paste_Over(@Make(T_Name, new_intersect, < >)) FI;
           @Up FI OD ENDVAR;


  C:" Sort tests to put off memory access tests in case of segfaults: ";
  VAR < index_vars := < > >:
  FOREACH Condition DO
    IF @ST(@I) = T_And OR @ST(@I) = T_Or
      THEN @Down;
           DO index_vars := @Find_Index_Vars;
	      IF @Right? THEN @Right ELSE EXIT(1) FI;
	      IF NOT EMPTY?((@Used(@I) \ @Find_Index_Vars) /\ index_vars)
	        THEN @Trans(TR_Move_To_Left, "");
		     @Right FI OD FI OD ENDVAR;



  C:" End of Simplification -- modified I is in @Program ";



  C:" Put macros into a separate file (so that they can be loaded first) ";
  C:" We assume that there are no FOREACH/ATEACH calls in a macro body! ";

  VAR < Macro_Filename := "", stat := < >, macro_decls := < >, new := < >,
	Output_Port := < > >:
  IF Filename = ""
    THEN Macro_Filename := ""
  ELSIF SUBSTR(Filename, SLENGTH(Filename) - 4, 4) = ".scm"
    THEN Macro_Filename := SUBSTR(Filename, 0, SLENGTH(Filename) - 4) ++ "-mac.scm"
    ELSE Macro_Filename := Filename ++ "-mac.scm" FI;
  C:" MW_PROC/FUNCT declarations are all on the top level: ";
  FOR stat IN @Cs(@Program) DO
    IF WS_Type[@ST(stat)] = Scheme_Decl AND @V(stat^1) IN Macros
      THEN macro_decls := <stat> ++ macro_decls;
	   new := <@Make(T_Comment, " Macro declaration: " ++ @N_String(@V(stat^1)), < >)> ++ new
      ELSE new := <stat> ++ new FI OD;
  C:" If there are macros, write a macro file, otherwise delete it: ";
  IF Macro_Filename = ""
    THEN Output_Port := Standard_Output_Port
    ELSE Output_Port := @Open_Output_File(Macro_Filename) FI;
  IF NOT EMPTY?(macro_decls)
    THEN IF WSL_Option_Quiet = 0
           THEN PRINT("Writing: " ++ Macro_Filename) FI;
	 FOR stat IN REVERSE(macro_decls) DO
	   @WS_Item(stat); @WSSL("") OD;
	 @Paste_Over(@Make(T_Statements, < >, REVERSE(new))) FI;
  IF Macro_Filename <> "" THEN @Close_Output_Port(Output_Port) FI ENDVAR;

  C:" Now write the main file: ";

  IF Filename = ""
    THEN Output_Port := Standard_Output_Port
    ELSE Output_Port := @Open_Output_File(Filename);
	 IF WSL_Option_Quiet = 0
           THEN PRINT("Writing: ", Filename) FI FI;
  @WSSL(";;; Scheme translation of WSL code");

  C:" Compute the list of global vars, ignoring parameters of MW_PROCs and functs ";
  C:" (unless they are used globally elsewhere) ";
  VAR < stat := < > >:
  FOR stat IN @Cs(@Program) DO
    IF @ST(stat) = T_MW_Proc
      THEN Globals := Globals \/ (@Variables(stat) \ @Variables(stat^2))
    ELSIF @ST(stat) = T_MW_Funct OR @ST(stat) = T_MW_BFunct
      THEN Globals := Globals \/
                         (@Variables(stat) \ @Variables(stat^2) \ @Assigned(stat^3))
      ELSE Globals := Globals \/ @Variables(stat) FI OD ENDVAR;


  C:" Process FOREACH and ATEACH clauses to generate top-level declarations ";
  C:" for the bodies: ";
  C:" NB: Add global vars in these clauses to the Globals list: ";
  C:" NB: Patterns (for MATCH/FILL) are also global variables! ";
  VAR < foreach := 0, name := "", body_var := < >, ST := 0,
	Foreach_Types := @Make_Set(
			 <T_Foreach_Stat, T_Foreach_Stats, T_Foreach_TS, T_Foreach_TSs,
			  T_Foreach_STS, T_Foreach_Expn, T_Foreach_Cond,
			  T_Foreach_NAS, T_Foreach_Variable, T_Foreach_Global_Var,
			  T_Foreach_Lvalue, 
			  T_Ateach_Stat, T_Ateach_Stats, T_Ateach_TS, T_Ateach_TSs,
			  T_Ateach_STS, T_Ateach_Expn, T_Ateach_Cond,
			  T_Ateach_NAS, T_Ateach_Variable, T_Ateach_Global_Var,
			  T_Ateach_Lvalue>),
	Only_Simple_Types := <T_Foreach_STS, T_Ateach_STS> >:

  C:" Note that this will process inner FOREACH/ATEACH clauses first: ";

  IF NOT EMPTY?(@Stat_Types(@I) /\ Foreach_Types)
    THEN FOREACH Statement DO
	   IF @ST(@I) IN Foreach_Types
	     THEN Globals := Globals \/ @Variables(@I^1) \/ @Match_Vars(@I^1);
		  foreach := foreach + 1;
		  name := @Make_Name("foreach-" ++ Input ++ "-" ++ @String(foreach));
		  body_var := @Make(T_Variable, name, < >);
		  @WSSL("(define (" ++ @WS_Name(name) ++ " "
			  ++ @WS_Name(@Make_Name("Depth")) ++ " "
			  ++ @WS_Name(@Make_Name("AS_Type")) ++ ")");
		  @WS_Items(@Cs(@I^1));
		  @WSSL(")"); @WSSL("");
		  C:" Replace the FOREACH by a suitable proc call: ";
		  ST := @ST(@I);
		  IF ST IN Only_Simple_Types
		    THEN @Paste_Over(FILL Statement
				     @Foreach(~?body_var, 0, @AS_Type, 1) ENDFILL)
		    ELSE @Paste_Over(FILL Statement
				     @Foreach(~?body_var, 0, @AS_Type, 0) ENDFILL) FI;
		  C:" Get the actual proc name from WS_Funct: ";
		  @Paste_Over(@Make(T_MW_Proc_Call, < >,
				    <@Name(@Make_Name(WS_Funct[ST]))> ++ TAIL(@Cs(@I))));
		  C:" Check for deletion of the whole program: ";
		  @Paste_After(FILL Statement
				 IF EMPTY?(@Program)
				   THEN @New_Program(@Skips) FI ENDFILL) FI OD FI ENDVAR;

  C:" Put the modified program back into I ";
  I := @Program;

  @Undo_Edit;

  IF @GT(I) = T_Statements
    THEN @WS_Items(@Cs(I))
    ELSE @WS_Item(I) FI;

  @WSSL("");
  IF Filename <> "" THEN @Close_Output_Port(Output_Port) FI ENDVAR ENDVAR .;


C:" Check for a FOREACH/ATEACH component or a called proc/function ";
C:" other than a macro or recursive call. ";
C:" If any of these are found, then local variables which mask globals ";
C:" must be copied into the global (and restored afterwards), ";
C:" so that they are visible to the called proc/function. ";

MW_BFUNCT @WS_Calls?(name, I) ==
  VAR < calls := 0, comps := @Components(I) >:
  IF @ST(I) IN Foreach_Types
    THEN calls := 1
  ELSIF @ST(I) = T_Maphash OR @ST(I) = T_Map OR @ST(I) = T_Reduce
    THEN calls := 1
  ELSIF @ST(I) IN Call_Types AND @V(I^1) <> name AND @V(I^1) NOTIN Macros
    THEN calls := 1
    ELSE WHILE calls = 0 AND NOT EMPTY?(comps) DO
	   IF @WS_Calls?(name, HEAD(comps))
	     THEN calls := 1
	     ELSE comps := TAIL(comps) FI OD FI;
  (calls = 1) .;



C:" Convert an item to Scheme, using the WS_Type and WS_Funct tables: ";

MW_PROC @WS_Item(I) ==
  VAR < ST := @ST(I), type := "", funct := "" >:
  type := WS_Type[ST];
  C:" If the value is a variable/proc name, then convert it here: ";
  C:" (Don't convert strings, numbers, EXIT values, or external function names) ";
  IF ST IN <T_Variable, T_Var_Lvalue>
    THEN funct := WS_Funct[ST] ++ @WS_Name(@V(I))
  ELSIF ST IN <T_For, T_Struct, T_Struct_Lvalue,
	       T_Proc_Call, T_Funct_Call, T_Action>
    THEN funct := WS_Funct[ST] ++ @WS_Name(@V(I^1))
  ELSIF ST = T_Call
    THEN funct := WS_Funct[ST] ++ @WS_Name(@V(I)) ++ "_a"
  ELSIF @Cs?(I) AND @ST(I^1) = T_Name
    THEN funct := WS_Funct[ST] ++ @N_String(@V(I^1))
    ELSE funct := WS_Funct[ST] ++ @String(@Value(I)) FI;

  IF FALSE
    THEN PRINT("@WS_Item: ST = ", @Type_Name(ST),
               " funct = ", funct, " type = ", type) FI;

  IF type = Scheme_Literal
    THEN @WSS(funct)

  ELSIF type = Scheme_Funct
    THEN IF funct <> "" AND @Size(I) > 0 THEN funct := funct ++ " " FI;
	 @WSS("(" ++ funct);
	 IF @Size(I) = 1 AND @GT(I^1) = T_Expressions
	   THEN @WS_Items(@Cs(I^1))
	 ELSIF @Size(I) = 2 AND @ST(I^1) = T_Name AND @GT(I^2) = T_Expressions
	   THEN @WS_Items(@Cs(I^2))
	 ELSIF @Size(I) > 1 AND @ST(I^1) = T_Name
	   THEN @WS_Items(TAIL(@Cs(I)))
	   ELSE @WS_Items(@Cs(I)) FI;
	 @WSS(")")

  ELSIF type = Scheme_Call
    THEN IF funct <> ""  AND (@Size(I^2) > 0 OR (@Size(I) > 2 AND @Size(I^3) > 0))
	   THEN funct := funct ++ " " FI;
	 VAR < var := < >, res := < > >:
	 C:" Special case: @Make_Name(str) --> 'str ";
	 C:" NB: SCM returns 'foo for 'FOO, so this doesn't work! ";
	 IF FALSE AND @V(I^1) = make_name AND @ST(I^2^1) = T_String
	   THEN @WSS("'" ++ @V(I^^<1, 1>))
	 ELSIF @Size(I) = 2 OR (@Size(I) = 3 AND @Size(I^3) = 0)
	   THEN C:" Simple proc or funct call: ";
		@WSS("(" ++ funct); @WS_Items(@Cs(I^2)); @WSS(")")
	 ELSIF @Size(I) = 3 AND @Size(I^3) = 1
	   THEN C:" A single VAR parameter -- result is returned by the funct ";
		@WS_Assign(I^3^1, @Make_Funct(@Make_Name(funct), @Cs(I^2) ++ @Cs(I^3)))
	 ELSIF @Size(I) = 3 AND @Size(I^3) > 1
	   THEN C:" Multiple results are returned: return a list which is ";
		C:" split up and assigned to the parameters ";
		@WSS("(let ((" ++ @WS_Name(tmp_result) ++ " ");
		@WS_Item(@Make_Funct(@Make_Name(funct), @Cs(I^2) ++ @Cs(I^3)));
		@WSS("))");
		res := @Make(T_Variable, tmp_result, < >);
		FOR var IN @Cs(I^3) DO
		  @WSSL("");
		  @WS_Assign(var, @Make(T_Head, < >, <res>)); @WSS(" ");
		  @WS_Assign(res, @Make(T_Tail, < >, <res>)) OD;
		@WSS(")")
	   ELSE PRINT("Unknown format of Scheme_Call: ", @Value(I));
		@Print_WSL(I, "") FI ENDVAR
		
   ELSIF type = Scheme_Decl
     THEN C:" Proc or Funct declaration ";
	  @WS_Decl(I)

   ELSIF type = Scheme_Ifmatch
     THEN C:" Some kind of IFMATCH1 ";
	  @WS_Ifmatch(I)

   ELSIF type = Scheme_Fill
     THEN C:" Some kind of FILL ";
	  @WS_Fill(I)

   ELSIF type = Scheme_Special
     THEN @WS_Special(I)

     ELSE ERROR("Unknown type: " ++ @String(type)) FI;

  C:" End of @WS_Item " ENDVAR .;


C:" Translate an IFMATCH1 construct <pattern, yes-sts, no-sts> ";

MW_PROC @WS_Ifmatch(I) ==
  VAR < vars := @Match_Vars(I^1), vals := < >, n := 0, pairs := < > >:

  ERROR("IFMATCH should be handeled by Ifmatch_Processing!");
  ERROR("Old version of Ifmatch is deprecated");

  FOR var IN vars DO
    pairs := <<var, "(@Make_Name " ++ Quote ++ @N_String(var) ++ Quote ++ ") ">>
                ++ pairs OD;
  C:" Set up a table with the current values of the listed vars: ";
  @WSS("(let* ((tab (list ");
  n := LENGTH(vars);
  FOR pair IN pairs DO
    @WSS("(cons " ++ pair[2] ++ @WS_Name(pair[1]) ++ ")");
    n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
  @WSSL("))");
  @WSS("(res (@Match ");
  C:" Write the raw internal format of the item: ";
  @WSS("`");
  @Write_Raw_Item(I^1, Output_Port);
  @WSSL(" (@I) tab)))");
  @WSSL("(if (not (null? res))");
  C:" Create local vars for the THEN part: ";
  @WSS("(let (");
  FOR pair IN pairs DO
    @WSS("(" ++ @WS_Name(pair[1]));
    @WSSL(" (cdr (assq " ++ pair[2] ++ " (cdr res))))") OD;
  @WSSL(")");
  @WS_Item(I^2);
  @WSSL(")"); C:" close the let ";
  @WS_Item(I^3);
  @WSSL("))"); C:" close the if and let* " ENDVAR .;


MW_FUNCT @Match_Vars(pat) == : SKIP;
  (IF @All_Pattern_Type?(@ST(pat)) AND @Has_Value_Type?(@ST(pat))
     THEN <@V(pat)>
     ELSE REDUCE("\\/", MAP("@Match_Vars", @Components(pat))) FI) .;



C:" Translate a FILL construct: build a suitable @Make structure and translate it ";

MW_PROC @WS_Fill(I) ==
  VAR < v_to_e := @Make_Name("@Var_To_Expn"),
        v_to_e_l := @Make_Name("@Var_To_Expn_List"),
	e_to_v := @Make_Name("@Expn_To_Var"),
	e_to_v_l := @Make_Name("@Expn_To_Var_List") >:
  @WS_Item(@Pattern_To_Make2(I^1)) ENDVAR .;

C:" Convert an item to a tree of @Make calls which will construct that item ";
C:" but with patterns replaced by the appropriate variables: ";

MW_FUNCT @Pattern_To_Make(I) ==
  VAR < comp := < >, new := < >, tr_new := < >, append := @Make_Name("append") >:
  C:" Build a list of translated components which form the components to an append ";
  C:" which, in turn, to forms the list of components for a @Make: ";
  FOR comp IN @Components(I) DO
    IF @Any_Pattern_Type?(@ST(comp)) OR @Many_Pattern_Type?(@ST(comp))
      THEN IF @GT(comp) = T_Expression
	     THEN new := <@Make_MWF(v_to_e_l, @Make(T_Variable, @V(comp), < >))> ++ new
	   ELSIF @GT(comp) = T_Lvalue
	     THEN new := <@Make_MWF(e_to_v_l, @Make(T_Variable, @V(comp), < >))> ++ new
	     ELSE new := <@Make(T_Variable, @V(comp), < >)> ++ new FI
      ELSE comp := @Pattern_To_Make(comp);
	   C:" Prepend the comp to the first T_Expressions in new, if there is one: ";
	   IF EMPTY?(new) OR @ST(new[1]) <> T_Expressions
	     THEN new := <@Make(T_Expressions, < >, <comp>)> ++ new
	     ELSE new[1] := @Make(T_Expressions, < >, <comp> ++ @Cs(new[1])) FI FI OD;
  C:" new is a list of variable/MW_Funct_Call/expressions items, convert it to an item ";
  FOR comp IN new DO
    IF @ST(comp) = T_Variable OR @ST(comp) = T_MW_Funct_Call
      THEN tr_new := <comp> ++ tr_new
      ELSE tr_new := <@Make(T_Sequence, < >,
			    <@Make(T_Expressions, < >,
				   REVERSE(@Cs(comp)))>)> ++ tr_new FI OD;
  IF EMPTY?(tr_new)
    THEN tr_new := @Make(T_Sequence, < >, <@Make(T_Expressions, < >, < >)>)
  ELSIF LENGTH(tr_new) = 1
    THEN tr_new := HEAD(tr_new)
    ELSE tr_new := @Make_Funct(append, tr_new) FI;

  (IF @One_Pattern_Type?(@ST(I))
    THEN IF @GT(I) = T_Expression
	   THEN @Make_MWF(v_to_e, @Make(T_Variable, @V(I), < >))
	 ELSE IF @GT(I) = T_Lvalue
	   THEN @Make_MWF(e_to_v, @Make(T_Variable, @V(I), < >))
	   ELSE @Make(T_Variable, @V(I), < >) FI FI
    ELSE @Make_Make(@ST(I), @Value(I), tr_new) FI) .;



C:" If the item is a pattern with a negative integer as the value or expression ";
C:" then let it pass through without being filled in ";
C:" (ie generate a @Make call which will return this pattern): ";

MW_FUNCT @Pattern_To_Make2(I) ==
  VAR < comp := < >, new := < >, tr_new := < >, append := @Make_Name("append") >:
  C:" Build a list of translated components which form the components to an append ";
  C:" which, in turn, to forms the list of components for a @Make: ";
  FOR comp IN @Components(I) DO
    IF (@Any_Pattern_Type?(@ST(comp)) OR @Many_Pattern_Type?(@ST(comp)))
         AND @V(comp) > 0
      THEN IF @GT(comp) = T_Expression
	     THEN new := <@Make_MWF(v_to_e_l, @Make(T_Variable, @V(comp), < >))> ++ new
	   ELSIF @GT(comp) = T_Lvalue
	     THEN new := <@Make_MWF(e_to_v_l, @Make(T_Variable, @V(comp), < >))> ++ new
	     ELSE new := <@Make(T_Variable, @V(comp), < >)> ++ new FI
    ELSIF @Any_Int_Type?(@ST(comp)) AND @ST(comp^1) <> T_Number
      THEN IF @GT(comp) = T_Expression
	     THEN new := <@Make_MWF(v_to_e_l, comp^1)> ++ new
	   ELSIF @GT(comp) = T_Lvalue
	     THEN new := <@Make_MWF(e_to_v_l, comp^1)> ++ new
	     ELSE C:" This item needs to be interpolated in the final list: ";
	          new := <comp> ++ new FI
    ELSIF @Any_Var_Type?(@ST(comp)) AND @V(comp) > 0
      THEN ERROR("Backreference variable interpolation ~*=var not valid in FILL!")
    ELSIF @One_Var_Type?(@ST(comp)) AND @V(comp) > 0
      THEN ERROR("Backreference variable interpolation ~?=var not valid in FILL!")
      ELSE comp := @Pattern_To_Make2(comp);
	   C:" Prepend the comp to the first T_Expressions in new, if there is one: ";
	   IF EMPTY?(new) OR @ST(new[1]) <> T_Expressions
	     THEN new := <@Make(T_Expressions, < >, <comp>)> ++ new
	     ELSE new[1] := @Make(T_Expressions, < >, <comp> ++ @Cs(new[1])) FI FI OD;
  C:" new is a list of variable/MW_Funct_Call/expressions items, convert it to an item ";
  FOR comp IN new DO
    IF @ST(comp) = T_Variable OR @ST(comp) = T_MW_Funct_Call
      THEN tr_new := <comp> ++ tr_new
    ELSIF @Any_Int_Type?(@ST(comp)) AND @ST(comp^1) <> T_Number
      THEN tr_new := <comp^1> ++ tr_new
      ELSE tr_new := <@Make(T_Sequence, < >,
			    <@Make(T_Expressions, < >,
				   REVERSE(@Cs(comp)))>)> ++ tr_new FI OD;
  IF EMPTY?(tr_new)
    THEN tr_new := @Make(T_Sequence, < >, <@Make(T_Expressions, < >, < >)>)
  ELSIF LENGTH(tr_new) = 1
    THEN tr_new := HEAD(tr_new)
    ELSE tr_new := @Make_Funct(append, tr_new) FI;

  (IF @One_Pattern_Type?(@ST(I)) AND @V(I) > 0
     THEN IF @GT(I) = T_Expression
            THEN @Make_MWF(v_to_e, @Make(T_Variable, @V(I), < >))
          ELSE IF @GT(I) = T_Lvalue
            THEN @Make_MWF(e_to_v, @Make(T_Variable, @V(I), < >))
            ELSE @Make(T_Variable, @V(I), < >) FI FI
   ELSE IF @One_Int_Type?(@ST(I)) AND @ST(I^1) <> T_Number
     THEN IF @GT(I) = T_Expression
            THEN @Make_MWF(v_to_e, I^1)
          ELSE IF @GT(I) = T_Lvalue
            THEN @Make_MWF(e_to_v, I^1)
            ELSE I^1 FI FI
     ELSE @Make_Make(@ST(I), @Value(I), tr_new) FI FI) .;



C:" Make a @Make function call with the given parameters ";
C:" (type is a number, value is a value, comps is an item): ";

MW_FUNCT @Make_Make(type, value, comps) == : SKIP;
  (@Make(T_MW_Funct_Call, < >,
	 <make_n,
	  @Make(T_Expressions, < >,
	  <@Make(T_Number, type, < >),
	   @WS_Value_To_Make(type, value),
	   comps>)>)) .;


MW_FUNCT @WS_Value_To_Make(type, value) ==
  VAR < R := < > >:
  IF EMPTY?(value)
    THEN R := @Make(T_Sequence, < >, <@Make(T_Expressions, < >, < >)>)
  ELSIF type = T_Number OR type = T_Exit
    THEN R := @Make(T_Number, value, < >)
  ELSIF type = T_String OR type = T_Comment
    THEN R := @Make(T_String, value, < >)
  ELSIF @All_Pattern_Type?(type)
    THEN C:" Value is either an identifier or a (negative) number: ";
         IF value > 0
	   THEN R := @Make_MWF(make_name, @Make(T_String, @N_String(value), < >))
	   ELSE R := @Make(T_Number, value, < >) FI
    ELSE C:" Assume it is a name ";
	 R := @Make_MWF(make_name, @Make(T_String, @N_String(value), < >)) FI;
  (R) .;


C:" Translate a PROC or FUNCT declaration ";
C:" If there is one VAR parameter, then return it. ";
C:" If there is more than one, then return them all in a list. ";
C:" Otherwise, return #t ";

MW_PROC @WS_Decl(I) ==
  VAR < ST := @ST(I) >:
  C:" Check for MW types first ";
  IF ST = T_MW_Proc
    THEN C:" values, vars, body ";
	 VAR < result := < > >:
	 C:" If there are var parameters, then either return the (single) par ";
	 C:" or return the list of pars as the result: ";
	 IF @Size(I^3) = 1
	   THEN result := I^3^1
	 ELSIF @Size(I^3) > 1
	   THEN result := @Make(T_Sequence, < >,
				<@Make(T_Expressions, < >,
				       MAP("@Lvalue_To_Expn", @Cs(I^3)))>) FI;
	 @WS_Funct_Decl(@V(I^1), @Cs(I^2) ++ @Cs(I^3), < >, I^4, result) ENDVAR

  ELSIF ST = T_MW_Funct OR ST = T_MW_BFunct
    THEN C:" pars, assigns, body, result ";
	 @WS_Funct_Decl(@V(I^1), @Cs(I^2), @Cs(I^3), I^4, I^5)

  ELSIF ST = T_Proc
    THEN C:" values, vars, body ";
	 @WSS("(" ++ @WS_Name(@V(I^1)) ++ " (lambda (");
	 @WS_Items(@Cs(I^2) ++ @Cs(I^3)); @WSSL(")");
	 IF @Size(I^4) <> 1 OR @ST(I^4^1) <> T_Skip
	   THEN @WS_Items(@Cs(I^4)); @WSSL("") FI;
	 IF @Size(I^3) = 0
	   THEN @WSSL("#t))")
	 ELSIF @Size(I^3) = 1
	   THEN @WS_Item(I^3^1); @WSSL("))")
	   ELSE @WSS("(list "); @WS_Items(@Cs(I^3)); @WSSL(")))") FI

  ELSIF ST = T_Funct OR ST = T_BFunct
    THEN C:" pars, assigns, body, result ";
	 @WSS("(" ++ @WS_Name(@V(I^1)) ++ " (lambda (");
	 @WS_Items(@Cs(I^2)); @WSSL(")");
	 @WSS("(let ");
	 C:" List of assigns: ";
	 @WS_Item(I^3); @WSSL("");
	 C:" Body: ";
	 IF @Size(I) = 5 THEN @WS_Item(I^4) FI;
	 C:" Result: ";
	 @WS_Item(I^@Size(I));
	 @WSSL(")))")

    ELSE PRINT("Unknown Declaration type: ", ST) FI ENDVAR .;


C:" Generate either a macro or function definition ";
C:" depending on whether the name is in the Macros list. ";
C:" big = 1 if the body to be generated will have more than one item ";
C:" (in which case a defmacro will need a (begin ...) enclosing the body) ";

MW_PROC @WS_Funct_Decl(name, pars, assigns, body, result) ==
  VAR < globals := < >, par := < >, new_pars := < >, big := 0, renames := < > >:
  C:" Check for calls: ";
  IF @Size(body) = 1 AND @ST(body^1) = T_Skip
    THEN C:" This is a pure function ";
         new_pars := pars
  ELSIF @WS_Calls?(name, body) OR (NOT EMPTY?(result) AND @WS_Calls?(name, result))
    THEN C:" Check for globals in the pars, add assigns to the block if necessary ";
	 C:" and rename the parameter to `name-par' ";
	 FOR par IN pars DO
	   IF @V(par) IN Globals
	     THEN assigns := <@Make(T_Assign, < >,
				    <par, @Make(T_Variable, @WS_Par(par), < >)>)>
				       ++ assigns;
		  renames := <@V(par)> ++ renames;
		  new_pars := <@Make(T_Var_Lvalue, @WS_Par(par), < >)> ++ new_pars
	     ELSE new_pars := <par> ++ new_pars FI OD;
	 new_pars := REVERSE(new_pars)
    ELSE new_pars := pars FI;

  C:" Write the header: ";
  IF name IN Macros
    THEN @WSS("(defmacro " ++ @WS_Name(name) ++ " (")
    ELSE @WSS("(define (" ++ @WS_Name(name));
	 IF NOT EMPTY?(new_pars) THEN @WSS(" ") FI FI;
  @WS_Items(new_pars); @WSSL(")");
  IF NOT EMPTY?(result) OR LENGTH(assigns) > 0
       OR @Size(body) > 1 OR @ST(body^1) <> T_Skip
    THEN big := 1 FI;
  IF name IN Macros
    THEN ws_macro_pars := MAP("@WS_Name", MAP("@V", new_pars));
	 IF big = 1
	   THEN @WSSL("`(begin")
	   ELSE @WSS("`") FI FI;

  C:" Write the var block, or just write the body and result: ";

  IF EMPTY?(assigns)
    THEN C:" Check for a body: ";
	 IF @Size(body) > 1 OR @ST(body^1) <> T_Skip
	   THEN @WS_Items(@Cs(body)) FI;
	 C:" Check for a result: ";
	 IF NOT EMPTY?(result) THEN @WSSL(""); @WS_Item(result) FI
    ELSE C:" Within the assigns, use name-par for the pars which shadow globals: ";
	 @Edit;
	 VAR < new_assigns := < >, assign := < >, var := < > >:
	 FOR assign IN assigns DO
	   @New_Program(assign);
	   @Down_To(2);
	   FOR var IN @Make_Set(renames) /\ @Variables(@I) DO
	     @Rename(var, @Make_Name(@N_String(var) ++ "-par")) OD;
	   new_assigns := <@Program> ++ new_assigns OD;
	 @WS_Var_Block(name, REVERSE(new_assigns), body, result) ENDVAR FI;

  C:" Write the footer: ";
  IF name IN Macros THEN ws_macro_pars := < > FI;
  IF name IN Macros AND big = 1
    THEN @WSSL("))")
    ELSE @WSSL(")") FI ENDVAR .;


C:" Rename a variable by adding `-par' and return the new name ";
MW_FUNCT @WS_Par(I) == : SKIP;
  (@Make_Name(@N_String(@V(I)) ++ "-par")) .;


C:" Generate a block (for Funct/Bfunct/Var) with local vars ";
C:" ensuring dynamic binding if necessary: ";

MW_PROC @WS_Var_Block(name, assigns, body, result) ==
  VAR < globals := < >, assign := < >, n := 0 >:
  C:" Check for calls: ";
  IF NOT @WS_Calls?(name, body) AND (EMPTY?(result) OR NOT @WS_Calls?(name, result))
    THEN C:" No need to check for globals "
    ELSE FOR assign IN assigns DO
	   IF @V(assign^1) IN Globals
	     THEN globals := <@V(assign^1)> ++ globals FI OD FI;
  IF EMPTY?(globals)
    THEN C:" We can use a simple let: ";
	 @WSS("(let (");
	 n := LENGTH(assigns);
	 FOR assign IN assigns DO
	   @WSS("("); @WS_Item(assign^1); @WSS(" ");
	   @WS_Item(assign^2); @WSS(")");
	   n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
	 @WSS(")"); C:" end of the let vars ";

	 C:" Check for a body: ";
	 IF @Size(body) <> 1 OR @ST(body^1) <> T_Skip
	   THEN @WSSL(""); @WS_Items(@Cs(body)) FI;

	 C:" Check for a result: ";
	 IF NOT EMPTY?(result) THEN @WSSL(""); @WS_Item(result) FI;
	 @WSS(")")

    ELSE C:" Save the values of global vars in local vars, ";
	 C:" initialise global vars, execute the body, save the result, ";
	 C:" restore the values of global vars and return the saved result: ";
	 @WSS("(let (");
	 n := LENGTH(assigns);
	 FOR assign IN assigns DO
	   IF @V(assign^1) IN globals
	     THEN @WSS("("); @WS_Item(assign^1); @WSS("-save ");
		  @WS_Item(assign^1); @WSS(")")
	     ELSE @WSS("("); @WS_Item(assign^1); @WSS(" ");
		  @WS_Item(assign^2); @WSS(")") FI;
	   n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
	 C:" Check if we need a local var for the result ";
	 IF NOT EMPTY?(result) AND NOT EMPTY?(globals)
	   THEN @WSSL(""); @WSS("(" ++ funct_result ++ " '())") FI;
	 @WSS(")"); C:" end of the let vars ";

	 C:" Assign the local values to the global vars: ";
	 FOR assign IN assigns DO
	   IF @V(assign^1) IN globals
	     THEN @WSSL(""); @WS_Assign(assign^1, assign^2) FI OD;

	 C:" Funct/BFunct/Var body: ";
	 IF @Size(body) > 1 OR @ST(body^1) <> T_Skip
	   THEN @WSSL(""); @WS_Items(@Cs(body)) FI;
	 C:" save result in funct_result if necessary: ";
	 IF NOT EMPTY?(result) AND NOT EMPTY?(globals)
	   THEN @WSSL(""); @WSS("(set! " ++ funct_result ++ " ");
		@WS_Item(result); @WSS(")") FI;

	 C:" Restore the global values: ";
	 FOR assign IN assigns DO
	   IF @V(assign^1) IN globals
	     THEN @WSSL(""); @WSS("(set! "); @WS_Item(assign^1);
		  @WSS(" "); @WS_Item(assign^1); @WSS("-save)") FI OD;

	 C:" Return the result: ";
	 IF NOT EMPTY?(result)
	   THEN @WSSL("");
		IF NOT EMPTY?(globals)
		  THEN @WSS(funct_result)
		  ELSE @WS_Item(result) FI FI;
	 @WSS(")") FI ENDVAR .;


C:" replace chars `from' by `to' in string, and return the result: ";

MW_FUNCT @WS_Replace(from, to, str) ==
  VAR < R := "", n := 0, from_len := SLENGTH(from) >:
  IF EMPTY?(str) THEN str := "" FI;
  DO n := INDEX(from, str);
     IF n < 0 THEN R := R ++ str; EXIT(1) FI;
     R := R ++ SUBSTR(str, 0, n) ++ to;
     str := SUBSTR(str, n + from_len) OD;
  (R) .;



MW_PROC @WS_Special(I) ==
  VAR < ST := @ST(I) >:
  IF ST = T_Statements
    THEN IF @Size(I) = 1
	   THEN @WS_Item(I^1)
	   ELSE @WSSL("(begin");
		@WS_Items(@Cs(I)); @WSS(")") FI
  ELSIF ST = T_String
    THEN C:" Ensure that the quotes are printed and backslash any backslashes: ";
	 @WSS(Quote ++ @Fix_Quotes(@V(I)) ++ Quote)
  ELSIF ST = T_Sequence
    THEN IF @Size(I^1) = 0
	   THEN @WSS("'()")
	   ELSE @WSS("(list "); @WS_Items(@Cs(I^1)); @WSS(")") FI
  ELSIF ST = T_Comment
    THEN C:" A comment must always be followed by a newline ";
	 C:" Insert ; after each newline in the comment ";
	 @WSSL(";" ++ @WS_Replace(Newline, Newline ++ ";", @V(I)))
  ELSIF ST = T_Assignment
    THEN C:" Check for a parallel assignment: ";
	 IF @Size(I) = 1
	   THEN IF @ST(I^1) = T_Assign
		  THEN @WS_Assign(I^^<1, 1>, I^^<1, 2>)
		  ELSE @WS_Item(I^1) FI
	 ELSIF EMPTY?(@Assigned(I) /\ @Used(I))
	   THEN C:" Can do the assignments in sequence ";
		VAR < assign := < >, n := @Size(I) >:
		FOR assign IN @Cs(I) DO
		  IF @ST(assign) = T_Assign
		    THEN @WS_Assign(assign^1, assign^2)
		    ELSE @WS_Item(assign) FI;
                  n := n - 1; IF n > 0 THEN @WSSL("") FI OD ENDVAR
	   ELSE C:" assign the values to temp vars ";
		VAR < n := 1, assign := < > >:
		@WSS("(let (");
		n := @Size(I);
		FOR assign IN @Cs(I) DO
		  IF @ST(assign) = T_Assign
		    THEN @WSS("(" ++ @WS_Name(@Make_Name(tmp_var ++ @String(n))) ++ " ");
			 @WS_Item(assign^2); @WSS(")")
		    ELSE @WS_Item(assign) FI;
		  n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
		@WSSL(")");
		C:" copy from temp vars to real vars ";
		n := @Size(I);
		FOR assign IN @Cs(I) DO
		  IF @ST(assign) = T_Assign
		    THEN @WS_Assign(assign^1,
				    @Make(T_Variable,
				          @Make_Name(tmp_var ++ @String(n)),
					  < >))
		    ELSE @WS_Item(assign) FI;
		  n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
		@WSS(")") ENDVAR FI

  ELSIF ST = T_A_S
    THEN VAR < action := < > >:
	 C:" A CALL Z terminates this action system: ";
	 @WSSL("(call-with-current-continuation (lambda (//Z) (letrec (");
	 FOR action IN @Cs(I^2) DO
	   IF @ST(action) = T_Action
	     THEN @WSSL("(" ++ @WS_Name(@V(action^1)) ++ "_a" ++ " (lambda ()");
		  @WS_Item(action^2);
		  @WSSL("))")
	     ELSE @WS_Item(action) FI OD;
	 @WSSL(")");
	 C:" Kick off with a call to the starting action: ";
	 @WSS("(" ++ @WS_Name(@V(I^1)) ++ "_a" ++ "))))") ENDVAR

  ELSIF ST = T_Call
    THEN C:" CALL Z requires a parameter: ";
	 IF @V(I) = z_name
	   THEN @WSS("(" ++ @WS_Name(@V(I)) ++ " #t)")
	   ELSE @WSS("(" ++ @WS_Name(@V(I)) ++ "_a" ++ ")") FI

  ELSIF ST = T_D_Do
    THEN VAR < guard := < >, n := 0 >:
	 @WSSL("(let D_Do_Loop ()");
	 @WSSL("(cond");
	 n := @Size(I);
	 FOR guard IN @Cs(I) DO
	   @WSS("("); @WS_Item(guard^1); @WSSL("");
	   @WS_Items(@Cs(guard^2)); @WSS(" (D_Do_Loop))");
	   n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
	 @WSS(")") ENDVAR

  ELSIF ST = T_Cond OR ST = T_D_If
    THEN VAR < guard := < >, comps := < >, n := 0 >:
	 @WSSL("(cond");
	 comps := @Cs(I);
	 C:" Ignore a redundant clause in a Cond ";
	 IF ST = T_Cond AND @ST(LAST(comps)^1) = T_True
	      AND @Size(LAST(comps)^2) = 1 AND @ST(LAST(comps)^^<2, 1>) = T_Skip
	   THEN comps := BUTLAST(comps) FI;
	 n := LENGTH(comps);
	 FOR guard IN comps DO
	   IF @ST(guard) = T_Guarded
	     THEN @WSS("("); @WS_Item(guard^1); @WSSL("");
		  @WS_Items(@Cs(guard^2)); @WSS(")")
	     ELSE @WS_Item(guard) FI;
	   n := n - 1; IF n > 0 THEN @WSSL("") FI OD;
	 @WSS(")") ENDVAR

  ELSIF ST = T_Exit
    THEN VAR < tv := floop_depth - @V(I) >:
	 IF tv < 0 THEN tv := 0 FI;
	 @WSS("(exit_" ++ @String(tv) ++ " #t)") ENDVAR

  ELSIF ST = T_Floop
    THEN @WSSL("(floop exit_" ++ @String(floop_depth));
	 floop_depth := floop_depth + 1;
	 @WS_Item(I^1);
	 floop_depth := floop_depth - 1;
	 @WSS(")")

  ELSIF ST = T_Var
    THEN C:" Save global values in local vars, then set! new values. ";
	 C:" (We have to do it this way for dynamic binding to work properly). ";
	 C:" But if there are no calls, we don't have to worry: ";
	 @WS_Var_Block(< >, @Cs(I^1), I^2, < >)

  ELSIF ST = T_Where
    THEN @WSS("(letrec ");
	 @WS_Item(I^2); @WSSL("");
	 @WS_Item(I^1); @WSSL(")")

  ELSIF ST = T_Aref
    THEN @WSS("(wsl-ref "); @WS_Item(I^1); @WSS(" ");
	 @WS_Items(@Cs(I^2)); @WSS(")")

  ELSIF ST = T_Struct OR ST = T_Struct_Lvalue
    THEN @WS_Item(I^2); @WSS("."); @WSS(@WS_Name(@V(I^1)))

  ELSIF ST = T_Equal
    THEN IF @WC_Numeric_Exp?(I^1) OR @WC_Numeric_Exp?(I^2)
	   THEN @WSS("(= ")
	   ELSE @WSS("(equal? ") FI;
	 @WS_Item(I^1); @WSS(" "); @WS_Item(I^2); @WSS(")")

  ELSIF ST = T_Not_Equal
    THEN @WSS("(not "); @WS_Item(@Make(T_Equal, < >, @Cs(I))); @WSS(")")

  ELSIF ST = T_For
    THEN @WSS("(for " ++ @WS_Name(@V(I^1))++ " "); @WS_Items(TAIL(@Cs(I))); @WSS(")")

  ELSIF ST = T_For_In
    THEN @WSS("(for-in " ++ @WS_Name(@V(I^1))++ " "); @WS_Items(TAIL(@Cs(I))); @WSS(")")

    ELSE PRINT("Unknown Scheme_Special type: ", ST) FI ENDVAR .;



C:" Write a list of items (space or newline separated) ";
C:" Statements are newline separated, but note that a comment already ";
C:" has the newline added. ";
MW_PROC @WS_Items(list) ==
  WHILE NOT EMPTY?(list) DO
    IF @GT(HEAD(list)) = T_Statements AND WS_Indent_Pending = 0
      THEN @WSSL("") FI;
    @WS_Item(HEAD(list));
    IF NOT EMPTY?(TAIL(list))
      THEN IF @GT(HEAD(list)) = T_Statement 
	     THEN IF @ST(HEAD(list)) <> T_Comment THEN @WSSL("") FI
	     ELSE @WSS(" ") FI FI;
    list := TAIL(list) OD .;



C:" Make an external funct call ";
MW_FUNCT @Make_Funct(name, comps) == : SKIP;
  (@Make(T_X_Funct_Call, < >,
	 <@Name(name), @Make(T_Expressions, < >, @Var_To_Expn_List(comps))>)) .;

C:" Make an external bfunct call ";
MW_FUNCT @Make_BFunct(name, comps) == : SKIP;
  (@Make(T_X_BFunct_Call, < >,
	 <@Name(name), @Make(T_Expressions, < >, @Var_To_Expn_List(comps))>)) .;

C:" Make an MW_FUNCT call with one argument: ";
MW_FUNCT @Make_MWF(name, arg) == : SKIP;
  (@Make(T_MW_Funct_Call, < >,
	 <@Name(name), @Make(T_Expressions, < >, <@Var_To_Expn(arg)>)>)) .;


C:" Generate an assignment (check for array references on LHS) ";
MW_PROC @WS_Assign(var, val) ==
  IF @ST(var) IN <T_Variable, T_Var_Lvalue> AND @Starts_With?(@V(var), "%const__")
    THEN C:" const definition ";
	 @WSS("(define "); @WS_Item(var);
	 @WSS(" "); @WS_Item(val); @WSS(")")
  ELSIF @ST(var) IN <T_Variable, T_Var_Lvalue, T_Struct, T_Struct_Lvalue,
		     T_Lvalue_Pat_One, T_Lvalue_Pat_Many, T_Lvalue_Pat_Any,
                     T_Mem_Lvalue, T_Mem_Seg_Lvalue, T_Mem_Rel_Lvalue>
    THEN C:" simple assignment ";
	 @WSS("(set! "); @WS_Item(var);
	 @WSS(" "); @WS_Item(val); @WSS(")")
  ELSIF @ST(var) = T_Aref_Lvalue
    THEN C:" Collect the indexes from nested Arefs: ";
	 VAR < indexes := < > >:
	 WHILE @ST(var) = T_Aref_Lvalue DO
	   indexes := @Cs(var^2) ++ indexes;
	   var := var^1 OD;
	 @WSS("(wsl-set! "); @WS_Item(var); @WSS(" ");
	 @WS_Item(val); @WSS(" "); @WS_Items(indexes); @WSS(")") ENDVAR
  ELSIF @ST(var) = T_Sub_Seg_Lvalue
    THEN @WS_Seg(var^1, var^2, var^3, val)
  ELSIF @ST(var) = T_Rel_Seg_Lvalue
    THEN @WS_Seg(var^1, var^2, @Make(T_Plus, < >, <var^2, var^3, m_one>), val)
  ELSIF @ST(var) = T_Final_Seg_Lvalue
    THEN @WS_Seg(var^1, var^2, @Make(T_Length, < >, <@Lvalue_To_Expn(var^1)>), val)
    ELSE PRINT("Unknown type in LHS of assign: ", @ST(var)) FI .;


C:" Generate code to replace a segment of an array or list: ";
MW_PROC @WS_Seg(var, from, to, val) ==
  @WS_Assign(var, @Make_Funct(@Make_Name("@Update_Segment"), <var, from, to, val>)) .;



C:" Convert a WSL name to a string suitable for a Scheme atom. ";
C:" Ensure that the result will distinguish upper and lower case. ";
C:" Add a prefix to all names (to avoid clashes with Scheme symbols) ";
C:" Replace backslash by _bs_ (to avoid problems after C compilation) ";
C:" Don't fix names that start with @ ";

MW_FUNCT @WS_Name(name) ==
  VAR < R := "", i := 0, caps := "ABCDEFGHIJKLMNOPQRSTUVWXYZ", prefix := "/" >:
  IF name < 0
    THEN R := @String(-name)
    ELSE name := @N_String(name);
         IF SUBSTR(name, 0, 1) = "@"
           THEN R := name
           ELSE R := prefix;
                FOR i := 0 TO SLENGTH(name) - 1 STEP 1 DO
                  IF INDEX(SUBSTR(name, i, 1), caps) >= 0
                    THEN R := R ++ prefix FI;
                  IF SUBSTR(name, i, 1) = Backslash
                    THEN R := R ++ "_bs_"
                    ELSE R := R ++ SUBSTR(name, i, 1) FI OD FI FI;
  (IF R IN ws_macro_pars
    THEN "," ++ R
    ELSE R FI) .;



MW_BFUNCT @WC_Numeric_Exp?(I) ==
  VAR < R := 0 >:
  IF @ST(I) = T_Variable
    THEN IF NOT EMPTY?(Num_Var_Types.(@V(I)))
	   THEN R := 1 FI
  ELSIF @ST(I) = T_MW_Funct_Call
    THEN IF NOT EMPTY?(Num_Funct_Types.(@V(I^1)))
	   THEN R := 1 FI
  ELSIF NOT EMPTY?(Num_Types.(@ST(I)))
    THEN R := 1 FI;
  (R = 1) .;



MW_BFUNCT @WS_Constant_Fill?(I) ==
  VAR < R := 1, ST := @ST(I), comps := < > >:
  IF @One_Pattern_Type?(ST) OR @Many_Pattern_Type?(ST) OR @Any_Pattern_Type?(ST)
       OR @One_Var_Type?(ST) OR @Any_Var_Type?(ST)
    THEN IF @V(I) > 0 THEN R := 0 FI
  ELSIF @One_Int_Type?(ST) OR @Any_Int_Type?(ST)
    THEN IF @ST(I^1) <> T_Number THEN R := 0 FI
  ELSIF @Cs?(I)
    THEN comps := @Cs(I);
         WHILE R = 1 AND NOT EMPTY?(comps) DO
	   IF NOT @WS_Constant_Fill?(HEAD(comps))
	     THEN R := 0
	     ELSE comps := TAIL(comps) FI OD FI;
  (R = 1) .;


C:" Return the set of variables used as indices in arrays: ";

MW_FUNCT @Find_Index_Vars() ==
  VAR < vars := < > >:
  FOREACH Expression DO
    IF @ST(@I) = T_Aref
      THEN vars := vars \/ @Used(@I^2)
    ELSIF @ST(@I) = T_Sub_Seg OR @ST(@I) = T_Rel_Seg
      THEN vars := vars \/ @Used(@I^2) \/ @Used(@I^3) FI OD;
  (vars) .;



SKIP

