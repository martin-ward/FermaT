(defmacro substr (str from . rest)
  (if (null? rest)
      `(let ((s ,str))
	 (substring s ,from (string-length s)))
      `(let ((f ,from))
         (substring ,str f (+ f ,@rest)))))
(defmacro display-list (item . rest)
  (if (null? rest)
      `(begin
	 (display ,item)
	 (newline)
	 (force-output))
      `(begin
	 (display ,item)
	 (display-list ,@rest))))
(defmacro display-list-flush (item . rest)
  (if (null? rest)
      `(begin
	 (display ,item)
	 (force-output))
      `(begin
	 (display ,item)
	 (display-list-flush ,@rest))))
(defmacro assertion (B)
  `(if ,B
       #t
       (error "assertion failed:" ',B)))
(defmacro while (B . S)
  `(let while-loop ()
     (cond (,B ,@S (while-loop))
	   (#t #t))))
(defmacro for (var start end step . body)
  `(let ((var-save ,var) (for-step ,step) (for-end ,end))
     (set! ,var ,start)
     (let for-loop ()
       (cond ((or (and (> ,step 0) (<= ,var for-end))
		  (and (< ,step 0) (>= ,var for-end)))
	      ,@body
	      (set! ,var (+ ,var for-step))
	      (for-loop))
	     (#t #t)))
     (set! ,var var-save)))
(defmacro for-in-orig (var seq . body)
  `(let ((var-save ,var))
     (let for-in-loop ((for-tmp ,seq))
       (cond ((not (null? for-tmp))
	      (set! ,var (car for-tmp))
	      ,@body
	      (for-in-loop (cdr for-tmp)))
	     (#t #t)))
     (set! ,var var-save)))
(defmacro for-in (var seq . body)
  `(let ((var-save ,var)
	 (seq-save ,seq))
     (if (vector? seq-save)
	 (set! seq-save (vector-elts seq-save)))
     (let for-in-loop ((for-tmp seq-save))
       (cond ((not (null? for-tmp))
	      (set! ,var (car for-tmp))
	      ,@body
	      (for-in-loop (cdr for-tmp)))
	     (#t #t)))
     (set! ,var var-save)))
(defmacro floop (name . body)
  `(call-with-current-continuation
     (lambda (,name)
       (do () (#f #t)
	  ,@body))))
(defmacro pop (v1 v2)
  `(begin
     (set! ,v1 (car ,v2))
     (set! ,v2 (cdr ,v2))))
(defmacro push (v e)
  `(set! ,v (cons ,e ,v)))
(defmacro hash-table ()
  `(my-make-hash-table 16))
(defmacro maphash (funct tab)
  `(let ((maphash-index 0) (key-val-pair '()))
     (for maphash-index 0 (- (vector-length ,tab) 1) 1
       (for-in key-val-pair (vector-ref ,tab maphash-index)
         (,(if (symbol? funct)
               funct
               (if (string? (cadr funct))
                   (string->symbol (cadr funct))
                   (cadr funct)))
          (car key-val-pair)
          (cdr key-val-pair))))))
(defmacro my-map (funct lst)
  `(let ((l ,lst) (map-result '()))
     (while (not (null? l))
       (set! map-result (cons (,funct (car l)) map-result))
       (set! l (cdr l)))
     (reverse map-result)))
(defmacro my-reduce (funct lst)
  `(let ((l ,lst) (reduce-result '()))
     (cond ((null? l)
	    '())
	   (#t
	    (set! reduce-result (car l))
	    (set! l (cdr l))
	    (while (not (null? l))
	      (set! reduce-result (,funct reduce-result (car l)))
	      (set! l (cdr l)))
	    reduce-result))))
(defmacro union-n args
  (if (= (length args) 1)
      (car args)
      `(@Set_Union ,(car args) (union-n ,@(cdr args)))))
(defmacro intersection-n args
  (if (= (length args) 1)
      (car args)
      `(@Set_Intersect ,(car args) (intersection-n ,@(cdr args)))))
(defmacro not-member (a b)
  `(not (member ,a ,b)))
(defmacro implies (a b)
  `(or (not ,a) ,b))
(defmacro tab_get (alist key)
  `(let ((result (assq ,key ,alist)))
     (if result
	 result
	 '())))
(defmacro make-vector-eval (N value)
  (if (pair? value)
      (if (eq? (car value) 'make-vector-eval)
          `(make-vector-eval-orig ,N ,value)
          `(make-vector ,N ,value))
      `(make-vector ,N ,value)))
(defmacro make-vector-eval-orig (N value)
  `(build-vector ,N (lambda (_) ,value)))
(defmacro wsl-ref (object index . rest)
  (if (null? rest)
      `(let ((name ,object))
	 (if (vector? name)
	     (vector-ref-safe name (- ,index 1))
	     (list-ref name (- ,index 1))))
      `(let ((name ,object))
	 (if (vector? name)
	     (wsl-ref (vector-ref-safe name (- ,index 1)) ,@rest)
	     (wsl-ref (list-ref name (- ,index 1)) ,@rest)))))
(defmacro vector-ref-safe (ar index)
  `(if (>= ,index (vector-length ,ar))
       (vector-ref ,ar 0)
       (vector-ref ,ar ,index)))
(defmacro wsl-set-orig! (object value index . rest)
  `(if (vector? ,object)
       (vector-set! (vector-refs ,object ,@rest)
		    (- ,index 1)
		    ,value)
       (set! ,object (new-struct ,object ,value ,index ,@rest))))
(defmacro wsl-set! (object value index . rest)
  (if (null? rest)
      `(if (vector? ,object)
	   (vector-set! ,object (- ,index 1) ,value)
	   (set! ,object (replace-nth ,object ,index ,value)))
      `(if (vector? ,object)
	   (let ((sub (vector-ref ,object (- ,index 1))))
	     (wsl-set! sub ,value ,@rest)
	     (vector-set! ,object (- ,index 1) sub))
           (let ((sub (car (nthcdr (- ,index 1) ,object))))
	     (wsl-set! sub ,value ,@rest)
	     (set! ,object (replace-nth ,object ,index sub))))))
(defmacro vector-refs (object . rest)
  (if (null? rest)
      object
      `(vector-refs (vector-ref ,object (- ,(car rest) 1)) ,@(cdr rest))))
(defmacro new-struct (object value . rest)
  (if (null? rest)
      value
      `(replace-nth ,object
		    ,(car rest)
		    (new-struct (list-ref ,object (- ,(car rest) 1))
				,value
				,@(cdr rest)))))
(defmacro @Get_n (lst n)
  (cond ((eq? ',n 1)
	 `(caddr ,lst))
	((eq? ',n 2)
	 `(cadddr ,lst))
	((eq? ',n 3)
	 `(car (cddddr ,lst)))
	(#t
	 `(list-ref ,lst (+ 1 ,n)))))
(defmacro @String_Less? (str1 str2)
  `(string<? ,str1 ,str2))
(defmacro @String_Less_Eq? (str1 str2)
  `(string<=? ,str1 ,str2))
(defmacro @ASCII_To_String (n)
  `(string (integer->char ,n)))
(defmacro my-index (sub str . rest)
  (if (null? rest)
      `(let ((index-result (substring? ,sub ,str)))
	 (if index-result
	     index-result
	     -1))
      `(let* ((s ,str) (start ,@rest)
	      (index-result (substring? ,sub (substring s start (string-length s)))))
	 (if index-result
	     (+ start index-result)
	     -1))))
(defmacro lowcase (str)
  `(my-string-downcase ,str))
(defmacro upcase (str)
  `(my-string-upcase ,str))
(defmacro swapcase (str)
  `(string-swapcase ,str))
(defmacro slength (str)
  `(string-length ,str))
(defmacro gen-length (x)
  `(if (vector? ,x)
       (vector-length ,x)
       (length ,x)))
(defmacro funct (name)
  (car name))
(defmacro set_car (pair obj)
  `(set-car! ,pair ,obj))
(defmacro HEAD (pair)
  `(car ,pair))
(defmacro TAIL (pair)
  `(cdr ,pair))
(defmacro printwsl (item . rest)
  (if (null? rest)
      `(@Print_WSL ,item "")
      `(@Print_WSL ,item ,@rest)))
(defmacro prit ()
  `(@Print_WSL (@I) ""))
(defmacro prpr ()
  `(@Print_WSL (@Program) ""))
